# 文档目录说明


## docs目录结构

```text
.
├── docs/
│   ├── requirements/                 # 需求文档（PRD）
│   │   ├── README.md
│   │   ├── prd_v0.1.md
│   │   ├── prd_v0.2.md
│   │   └── template-prd.md
│   ├── adr/                          # 架构决策记录（按平台分区）
│   │   ├── README.md
│   │   ├── template.md
│   │   └── iOS-macOS/
│   │       ├── 0001-multiplatform-architecture.md
│   │       ├── 0002-player-view-ui-stack.md
│   │       ├── 0003-sqlite-storage-solution.md
│   │       ├── 0004-logging-metrics-strategy.md
│   │       └── 0005-testing-di-strategy.md
│   ├── scrum/                        # Scrum 过程文档（平台分目录）
│   │   ├── Android/
│   │   │   ├── README.md
│   │   │   └── tasks/
│   │   │       └── sprint-0/
│   │   │           └── task-001-project-init.md
│   │   └── iOS-macOS/
│   │       ├── sprint-plan-v0.2-updated.md
│   │       ├── reviews/
│   │       └── tasks/
│   │           └── sprint-0/
│   │               ├── task-001-repo-init.md
│   │               ├── task-002-multiplatform-scaffold.md
│   │               ├── task-003-code-quality-baseline.md
│   │               ├── task-004-ci-baseline.md
│   │               └── ...
│   ├── licenses/
│   └── models/
├── tdd/                              # 技术设计文档（HLD/LLD）
│   ├── README.md
│   ├── Android/
│   │   └── hld-android-v0.2.md
│   └── iOS-macOS/
│       └── hld-ios-macos-v0.2.md
└── ...
```

## 快速索引（README 与模板）

- ADR
  - 目录说明：`docs/adr/README.md`
  - 模板：`docs/adr/template.md`
- Requirements（PRD）
  - 目录说明：`docs/requirements/README.md`
  - PRD 模板：`docs/requirements/template-prd.md`
- Scrum（敏捷过程）
  - 目录说明：`docs/scrum/README.md`
  - Sprint 计划模板：`docs/scrum/template-sprint-plan.md`
  - Task 模板：`docs/scrum/template-task.md`
- TDD（技术设计文档）
  - 目录说明：`tdd/README.md`
  - TDD 模板：`tdd/template-tdd.md`

## 设计文档分类原则

| 文档类型 | 目录位置 | 粒度 | 生命周期 |
|---------|---------|------|---------|
| **PRD** | requirements | 产品功能级 | 长期维护（版本化） |
| **HLD/TDD** | tdd | 架构/模块级 | 长期维护（版本化） |
| **ADR** | `docs/adr/` | 关键技术决策 | 永久保留（不可变） |
| **Task Design** | `docs/scrum/tasks/sprint-N/` | 实现任务级 | Sprint 周期内有效 |

### ADR vs TDD/HLD 职责边界说明

**两者不重复，而是互补关系**：

| 维度 | ADR (Architecture Decision Records) | TDD/HLD (Technical Design Document) |
|------|-------------------------------------|-------------------------------------|
| **核心问题** | **为什么**这样设计？ | **是什么**设计？**怎么**实现？ |
| **内容焦点** | 决策过程、备选方案对比、权衡理由 | 完整架构、模块设计、接口定义 |
| **典型内容** | • 2-3 个候选方案对比<br>• 决策驱动因素<br>• 选择理由与预期影响<br>• 简要的"What"（不含详细实现） | • 系统架构图<br>• 组件职责与接口<br>• 数据流与时序图<br>• 技术栈与依赖关系 |
| **文档结构** | 背景 → 方案对比 → 决策 → 后果 | 目标 → 架构 → 模块设计 → 接口规范 |
| **示例** | "为什么选 Workspace + SPM 而不是单工程？"<br>→ 对比表格 + 理由 | "多平台工程是什么样的？"<br>→ 完整目录结构 + 依赖图 |
| **修改性** | ❌ 不可修改（决策历史记录）<br>废弃时标记 Superseded | ✅ 可迭代更新（随架构演进） |
| **引用关系** | ADR → 引用 HLD 章节号获取详细设计 | HLD → 引用 ADR 说明设计依据 |

### 协同工作示例

以"多平台架构"为例的文档分工：

```
┌─────────────────────────────────────────────────────────────────┐
│ ADR-0001: 多平台工程架构决策                                      │
│                                                                 │
│ 问题: 如何组织 iOS + macOS 代码？                                │
│                                                                 │
│ 备选方案:                                                        │
│ ❌ 方案 1: 单工程 + Shared 文件夹                                │
│    优点: 简单  缺点: 模块边界不清晰                               │
│                                                                 │
│ ✅ 方案 2: Workspace + Swift Package（选定）                     │
│    优点: 模块化、可测试  缺点: 配置复杂                           │
│                                                                 │
│ 决策理由: 核心逻辑复用率 90%，需要模块级独立测试                  │
│                                                                 │
│ 📎 详细设计见: HLD v0.2 §13 工程结构                             │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 引用
┌─────────────────────────────────────────────────────────────────┐
│ HLD v0.2 §13: 工程结构                                           │
│                                                                 │
│ 📎 架构选择依据: ADR-0001                                        │
│                                                                 │
│ 目录结构:                                                        │
│ prism-player/                                                   │
│ ├── PrismPlayer.xcworkspace                                     │
│ ├── apps/                                                       │
│ │   ├── PrismPlayer-iOS/                                        │
│ │   └── PrismPlayer-macOS/                                      │
│ └── packages/                                                   │
│     ├── PrismCore/                                              │
│     ├── PrismASR/                                               │
│     └── PrismKit/                                               │
│                                                                 │
│ 依赖关系图: [详细依赖图]                                         │
│ 构建流程: [详细说明]                                             │
│ 测试策略: [详细说明]                                             │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 细化
┌─────────────────────────────────────────────────────────────────┐
│ Task-002: 搭建多平台工程 (Sprint 0)                              │
│                                                                 │
│ 执行步骤:                                                        │
│ 1. 创建 Workspace                                               │
│ 2. 配置 SPM packages                                            │
│ 3. 集成 SwiftLint                                               │
│ 4. CI 配置                                                      │
│                                                                 │
│ 验收标准: [具体清单]                                             │
└─────────────────────────────────────────────────────────────────┘
```

## Task 设计文档模板示例

````markdown
# Task-102: AsrEngine 协议定义与 WhisperCpp 后端实现

## 任务信息
- **Sprint**: Sprint 1
- **PBI**: AsrEngine 协议定义与 WhisperCppBackend（5 SP）
- **负责人**: @developer-name
- **状态**: In Progress / Review / Done
- **相关文件**:
  - `packages/PrismASR/Sources/AsrEngine.swift`
  - `packages/PrismASR/Sources/WhisperCppBackend.swift`
  - `packages/PrismASR/Tests/AsrEngineTests.swift`

## 设计目标
实现 AsrEngine 协议抽象，完成 whisper.cpp 后端集成，支持 gguf 模型加载与离线推理。

## 技术方案

### 1. 协议定义
```swift
// filepath: packages/PrismASR/Sources/AsrEngine.swift
public protocol AsrEngine {
    func transcribe(
        audioData: Data,
        options: AsrOptions
    ) async throws -> [AsrSegment]
}

public struct AsrOptions {
    let language: AsrLanguage?
    let enableTimestamps: Bool
    // ...
}
```

### 2. Whisper.cpp 集成策略
- 使用 SPM 包装或直接依赖
- Metal/Accelerate 后端自动选择
- 模型路径与加载策略

### 3. 测试策略
- 协议契约测试（Mock Backend）
- 金样本回归（3 段音频 × 10-30s）
- 性能基线记录

## 验收标准 (AC)
- [ ] AsrEngine 协议定义完成
- [ ] WhisperCppBackend 实现通过单测
- [ ] 金样本 WER < 15%
- [ ] 文档与示例代码完整

## 依赖与风险
- whisper.cpp 版本锁定
- Metal 兼容性测试（iOS 17+ / macOS 14+）

## 参考
- HLD §6.1/§6.2
- whisper.cpp 官方文档
````

## 关键原则



 

### 1. 分层设计原则

- **PRD**：定义"做什么"（What）和"为什么"（Why） - 产品视角
- **ADR**：记录"为什么这样设计"（Why）- 决策推理
- **HLD**：定义"是什么"（What）和概要"怎么做"（How）- 架构视角
- **Task**：定义"具体怎么做"（Detailed How）- 实现视角

### PRD vs TDD 

PRD 文档应该聚焦于"做什么"（What）和"为什么"（Why），而不是"怎么做"（How）。架构图、线程模型、DI 策略等属于**技术设计文档（Technical Design Document, TDD）**的范畴，不应该出现在 PRD 中。


| 文档类型 | 核心职责 | 典型内容 | 负责人 |
|---------|---------|---------|--------|
| **PRD** | 定义产品需求 | 用户故事、功能列项、验收标准、成功指标 | PM/产品经理 |
| **TDD** | 定义技术方案 | 架构设计、API 设计、数据模型、技术选型细节 | 技术负责人/架构师 |

### 2. ADR 写作规范

**✅ 应该包含的内容**：
- 问题陈述（1-2 段，清晰描述需要决策的场景）
- 决策驱动因素（业务、技术、团队约束）
- 2-3 个备选方案的对比表格（简明扼要）
- 决策结果与关键理由
- 预期影响（正面/负面后果）
- 引用 HLD/PRD 获取详细设计

**❌ 不应该包含的内容**：
- 完整代码实现（超过 20 行的代码块）
- 详细的类图/时序图（应放在 HLD 中）
- 配置步骤和操作指南（应放在 Task 或 README）
- 与决策无关的背景知识

**示例对比**：

| ❌ ADR 中不恰当的内容 | ✅ 应该出现的位置 |
|---------------------|-----------------|
| 完整的目录树结构（50+ 行） | HLD §13 工程结构 |
| SwiftLint 配置步骤 | Task-002 或 README |
| 测试框架完整使用教程 | HLD §10 测试策略 |
| 所有 Mock 类的实现 | 代码仓库 Tests/Mocks/ |

### 3. 可追溯性原则

- **Task 设计**必须关联 PBI 与 Sprint
- **ADR** 需引用相关 PRD/HLD 章节号
- **HLD** 需引用关键决策的 ADR 编号
- 使用双向链接：`📎 详细设计见 HLD v0.2 §6.1` ↔ `📎 决策依据见 ADR-0003`

### 4. 生命周期管理

- **Task 设计**：Sprint 结束后归档到 `tasks/sprint-N/`
- **ADR**：永久保留，废弃时标记状态为 `Superseded by ADR-XXXX`
- **HLD**：版本化管理（v0.1, v0.2...），重大变更时创建新版本
- **通用设计**：从 Task 提取，合并回 HLD（长期维护）

### 5. 文件命名规范

- **ADR**: `<4位编号>-<短横线分隔描述>.md`（如 `0001-multiplatform-architecture.md`）
- **Task**: `task-<编号>-<简短描述>.md`（如 `task-102-asr-engine-protocol.md`）
- **HLD**: `hld-<平台>-<版本>.md`（如 `hld-ios-macos-v0.2.md`）
- **PRD**: `prd_<版本>.md`（如 `prd_v0.2.md`）

## 文档审查清单

### ADR 审查检查项

在提交 ADR 前，确认以下事项：

- [ ] **标题清晰**：能从标题直接看出决策主题
- [ ] **状态明确**：标注当前状态（提议中/已接受/已废弃/已替代）
- [ ] **问题陈述完整**：清楚说明需要决策的场景和约束
- [ ] **方案对比充分**：至少有 2 个备选方案，且对比维度明确
- [ ] **理由充分**：说明为什么选择此方案，而不是其他方案
- [ ] **影响分析**：列出预期的正面和负面后果
- [ ] **引用明确**：相关 PRD/HLD 章节有明确链接
- [ ] **内容精简**：没有冗长的代码实现或配置步骤
- [ ] **永久性**：内容是决策历史记录，不会频繁修改

### HLD 审查检查项

- [ ] **架构完整**：系统组件、分层、数据流都有说明
- [ ] **接口清晰**：关键协议和接口有定义
- [ ] **技术栈明确**：框架、库、工具链有说明
- [ ] **非功能需求**：性能、安全、可测试性有考虑
- [ ] **平台差异**：iOS/macOS 特定部分有明确标注
- [ ] **ADR 引用**：关键设计有引用对应的决策记录
- [ ] **版本标识**：文档版本号与 PRD 版本对应

### Task 设计审查检查项

- [ ] **关联明确**：关联的 Sprint 和 PBI 编号正确
- [ ] **目标清晰**：能明确知道这个 Task 要实现什么
- [ ] **验收标准具体**：AC 清单可执行、可验证
- [ ] **技术方案详细**：包含代码示例、配置说明
- [ ] **测试策略**：说明如何测试和验证
- [ ] **依赖识别**：列出前置依赖和潜在风险
- [ ] **参考完整**：引用相关的 HLD 章节和文档

## 常见问题 FAQ

### Q1: 某个技术决策应该写 ADR 还是直接写在 HLD 里？

**判断标准**：
- 如果是**有争议的、有多个备选方案的、未来可能被质疑的**决策 → **写 ADR**
- 如果是**显而易见的、行业标准的、团队共识的**选择 → **直接写 HLD**

**示例**：
- ✅ ADR: "为什么选 Swift Package 而不是 CocoaPods"（有争议）
- ❌ ADR: "为什么用 Swift 而不是 Objective-C"（显而易见）
- ✅ ADR: "为什么用协议式 DI 而不是依赖注入框架"（有多个方案）
- ❌ ADR: "为什么用 Git 做版本管理"（行业标准）

### Q2: ADR 和 HLD 内容重复怎么办？

**解决方案**：
- ADR 只写**决策过程**（为什么），用简表对比方案
- HLD 写**设计结果**（是什么），用详图描述架构
- 两者互相引用：
  - ADR 末尾：`📎 详细设计见 HLD v0.2 §X.X`
  - HLD 对应章节：`📎 决策依据见 ADR-00XX`

### Q3: Sprint Task 设计文档要写多详细？

**原则**：
- **足够详细**以便其他开发者接手或 Code Review
- **不过度设计**，避免写成完整的技术手册
- **以实现为导向**，重点是"怎么做"而不是"为什么"

**建议长度**：
- 简单 Task（1-2 SP）：1-2 页，简要方案 + AC
- 中等 Task（3-5 SP）：2-4 页，详细方案 + 测试策略
- 复杂 Task（8+ SP）：考虑拆分，或写 4-6 页设计文档

### Q4: 什么时候需要更新文档？

| 场景 | 需要更新的文档 | 操作方式 |
|------|--------------|----------|
| 需求变更 | PRD | 版本升级（v0.2 → v0.3） |
| 架构调整 | HLD | 更新对应章节，记录变更日期 |
| 决策废弃 | ADR | 标记状态为 `Superseded by ADR-XXXX` |
| 实现完成 | Task | 更新状态为 Done，归档 |
| 新的重要决策 | ADR | 创建新的 ADR-XXXX.md |

**重要**：ADR 原则上不修改，只能通过新 ADR 替代旧 ADR。

---

## 总结

这样可以保持文档清晰分层，同时支持敏捷迭代过程中的详细设计记录：

```
PRD (产品需求) → ADR (关键决策) → HLD (架构设计) → Task (实现细节)
     ↓                ↓                 ↓                ↓
  做什么？          为什么？           是什么？          怎么做？
```

**文档协同工作流程**：
1. **需求阶段**：编写/更新 PRD
2. **设计阶段**：根据 PRD 编写 HLD，遇到关键技术选择时创建 ADR
3. **迭代阶段**：根据 HLD 拆分 Sprint，为复杂 Task 创建设计文档
4. **实现阶段**：参考 Task 设计文档实现功能
5. **Review 阶段**：检查代码与设计文档一致性
6. **归档阶段**：Sprint 结束后归档 Task 文档，总结经验更新 HLD