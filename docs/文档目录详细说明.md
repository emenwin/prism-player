# 文档目录说明


## docs目录结构

```text
.
├── docs/
│   ├── template/                     # 📝 统一模板目录
│   │   ├── 0.prd.template.md         # PRD 模板
│   │   ├── 1.adr.template.md         # ADR 模板
│   │   ├── 2.sprint-plan.template.md # Sprint 计划模板
│   │   ├── 3.sprint-task-list.template.md # Sprint 任务清单模板
│   │   ├── 4.tdd.template.md         # TDD/HLD 模板
│   │   └── 5.task-详细设计.template.md # Task 详细设计模板
│   ├── requirements/                 # 需求文档（PRD）
│   │   ├── README.md
│   │   ├── prd_v0.1.md
│   │   └── prd_v0.2.md
│   ├── adr/                          # 架构决策记录（按平台分区）
│   │   ├── README.md
│   │   └── iOS-macOS/
│   │       ├── 0001-multiplatform-architecture.md
│   │       ├── 0002-player-view-ui-stack.md
│   │       ├── 0003-sqlite-storage-solution.md
│   │       ├── 0004-logging-metrics-strategy.md
│   │       └── 0005-testing-di-strategy.md
│   ├── scrum/                        # Scrum 过程文档（平台分目录）
│   │   ├── Android/
│   │   │   ├── README.md
│   │   │   └── tasks/
│   │   │       └── sprint-0/
│   │   │           └── task-001-project-init.md
│   │   └── iOS-macOS/
│   │       ├── sprint-plan-v0.2-updated.md
│   │       ├── reviews/
│   │       └── tasks/
│   │           └── sprint-0/
│   │               ├── task-001-repo-init.md
│   │               ├── task-002-multiplatform-scaffold.md
│   │               ├── task-003-code-quality-baseline.md
│   │               ├── task-004-ci-baseline.md
│   │               └── ...
│   ├── tdd/                          # 技术设计文档（HLD/LLD）
│   │   ├── README.md
│   │   ├── Android/
│   │   │   └── hld-android-v0.2.md
│   │   └── iOS-macOS/
│   │       └── hld-ios-macos-v0.2.md
│   ├── licenses/
│   └── models/
└── ...
```

## 快速索引（README 与模板）

所有模板统一存放在 `docs/template/` 目录下。

- **PRD（产品需求文档）**
  - 目录说明：`docs/requirements/README.md`
  - 模板：`docs/template/0.prd.template.md`
  
- **ADR（架构决策记录）**
  - 目录说明：`docs/adr/README.md`
  - 模板：`docs/template/1.adr.template.md`
  
- **Sprint Plan（冲刺计划）**
  - 目录说明：`docs/scrum/README.md`
  - 模板：`docs/template/2.sprint-plan.template.md`
  
- **Sprint Task List（任务清单）**
  - 目录说明：`docs/scrum/README.md`
  - 模板：`docs/template/3.sprint-task-list.template.md`
  
- **TDD/HLD（技术设计文档）**
  - 目录说明：`docs/tdd/README.md`
  - 模板：`docs/template/4.tdd.template.md`
  
- **Task 详细设计**
  - 目录说明：`docs/scrum/README.md`
  - 模板：`docs/template/5.task-详细设计.template.md`

## 设计文档分类原则

| 文档类型 | 目录位置 | 粒度 | 生命周期 |
|---------|---------|------|---------|
| **PRD** | requirements | 产品功能级 | 长期维护（版本化） |
| **HLD/TDD** | tdd | 架构/模块级 | 长期维护（版本化） |
| **ADR** | `docs/adr/` | 关键技术决策 | 永久保留（不可变） |
| **Task Design** | `docs/scrum/tasks/sprint-N/` | 实现任务级 | Sprint 周期内有效 |

### ADR vs TDD/HLD vs Task详细设计 职责边界说明

**三者不重复，而是逐层递进、互补关系**：

| 维度 | ADR<br>(Architecture Decision Records) | TDD/HLD<br>(Technical Design Document) | Task 详细设计<br>(Task Design Document) |
|------|----------------------------------------|----------------------------------------|----------------------------------------|
| **核心问题** | **为什么**这样设计？ | **是什么**设计？<br>**概要怎么**实现？ | **具体怎么**实现？<br>**怎么**验证？ |
| **抽象层级** | 决策层（Why） | 架构层（What + How概要） | 实现层（How详细） |
| **内容焦点** | • 决策过程记录<br>• 备选方案对比<br>• 权衡理由与取舍 | • 完整系统架构<br>• 模块职责划分<br>• 接口协议定义<br>• 技术栈选型 | • 具体代码实现<br>• 详细步骤拆解<br>• 测试验收标准<br>• 实现时序安排 |
| **典型内容** | • 2-3 个候选方案对比表<br>• 决策驱动因素分析<br>• 选择理由与预期影响<br>• 简要的 What（不含详细实现） | • 系统架构图与分层<br>• 组件职责与依赖关系<br>• 核心接口与数据模型<br>• 关键流程时序图<br>• 技术栈与工具链 | • 具体代码片段（20-50行）<br>• 文件路径与命名<br>• 实现步骤清单<br>• 单元测试用例<br>• AC验收标准 |
| **文档结构** | • 背景与问题<br>• 方案对比<br>• 决策结果<br>• 预期后果 | • 目标与范围<br>• 架构设计<br>• 模块设计<br>• 接口规范<br>• 部署策略 | • 任务信息<br>• 设计目标<br>• 技术方案<br>• 实现步骤<br>• 验收标准<br>• 依赖与风险 |
| **粒度示例** | "为什么选 Workspace + SPM<br>而不是单工程？"<br>→ 对比表格 + 决策理由 | "多平台工程架构是什么样的？"<br>→ 完整目录结构 + 依赖图<br>→ Package 职责划分 | "如何实现 AsrEngine 协议？"<br>→ 协议定义代码<br>→ WhisperCpp 集成步骤<br>→ 测试金样本列表 |
| **代码深度** | ❌ 无代码<br>（仅概念对比） | ⚠️ 接口级代码<br>（协议定义、类签名，<20行） | ✅ 实现级代码<br>（核心逻辑示例，20-50行） |
| **生命周期** | 永久保留<br>（不可修改，废弃时标记） | 长期维护<br>（版本化迭代） | Sprint 周期<br>（完成后归档） |
| **修改性** | ❌ 不可修改<br>废弃时标记 `Superseded by ADR-XXXX` | ✅ 可迭代更新<br>记录变更历史 | ✅ Sprint 内迭代<br>完成后归档到 `tasks/sprint-N/` |
| **适用场景** | • 关键技术选型<br>• 架构重大变更<br>• 有争议的决策<br>• 需要历史记录的决策 | • 系统整体架构<br>• 模块划分策略<br>• 跨模块接口设计<br>• 技术方案总览 | • PBI 的具体实现<br>• 复杂功能开发<br>• 需要 Code Review 的任务<br>• 团队协作任务 |
| **文件位置** | `docs/adr/<平台>/` | `docs/tdd/<平台>/` | `docs/scrum/<平台>/tasks/sprint-N/` |
| **引用关系** | ADR → 引用 HLD 章节获取详细设计<br>ADR → 不引用 Task | HLD → 引用 ADR 说明设计依据<br>HLD → 被 Task 引用 | Task → 引用 HLD 章节<br>Task → 引用相关 ADR（可选） |
| **读者对象** | 架构师、Tech Lead、<br>未来维护者 | 全体开发团队、<br>新成员 Onboarding | 任务执行者、<br>Code Reviewer |
| **模板位置** | `docs/template/1.adr.template.md` | `docs/template/4.tdd.template.md` | `docs/template/5.task-详细设计.template.md` |

### 三层文档协同工作示例

以"多平台架构"为例的文档分工（ADR → HLD → Task 逐层细化）：

```
┌─────────────────────────────────────────────────────────────────┐
│ 📋 ADR-0001: 多平台工程架构决策（决策层 - Why）                   │
│                                                                 │
│ ❓ 问题: 如何组织 iOS + macOS 代码以最大化复用？                  │
│                                                                 │
│ 📊 备选方案对比:                                                 │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 方案 1: 单工程 + Shared 文件夹                            │   │
│ │ ✅ 优点: 简单、入门快                                     │   │
│ │ ❌ 缺点: 模块边界不清晰、测试困难、编译慢                  │   │
│ └──────────────────────────────────────────────────────────┘   │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ ✅ 方案 2: Workspace + Swift Package（选定）              │   │
│ │ ✅ 优点: 模块化、可独立测试、并行编译                      │   │
│ │ ❌ 缺点: 初期配置复杂、学习成本                           │   │
│ └──────────────────────────────────────────────────────────┘   │
│                                                                 │
│ ✅ 决策: 选择方案 2                                             │
│ 💡 理由:                                                        │
│    • 核心逻辑复用率预计 90%，需要清晰模块边界                   │
│    • 独立测试可提升代码质量和 CI 效率                           │
│    • 符合 Swift 生态最佳实践                                    │
│                                                                 │
│ 📎 详细架构设计见: HLD v0.2 §13 工程结构                        │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 引用（获取详细设计）
┌─────────────────────────────────────────────────────────────────┐
│ 📐 HLD v0.2 §13: 工程结构设计（架构层 - What）                   │
│                                                                 │
│ 📎 架构选择依据: ADR-0001                                        │
│                                                                 │
│ 🏗️ 目录结构:                                                     │
│ prism-player/                                                   │
│ ├── PrismPlayer.xcworkspace      # 工作空间                     │
│ ├── apps/                        # 应用层                       │
│ │   ├── PrismPlayer-iOS/         # iOS 应用 Target             │
│ │   └── PrismPlayer-macOS/       # macOS 应用 Target           │
│ └── packages/                    # 共享模块                     │
│     ├── PrismCore/               # 核心业务逻辑（平台无关）      │
│     ├── PrismASR/                # 语音识别引擎                 │
│     └── PrismKit/                # UI 组件库（跨平台）          │
│                                                                 │
│ 🔗 模块依赖关系:                                                 │
│ ┌─────────────┐     ┌──────────────┐                           │
│ │ iOS App     │────▶│  PrismKit    │                           │
│ └─────────────┘     └──────────────┘                           │
│ ┌─────────────┐            │                                   │
│ │ macOS App   │────────────┘                                   │
│ └─────────────┘            ▼                                   │
│                     ┌──────────────┐                           │
│                     │  PrismCore   │◀───┐                      │
│                     └──────────────┘    │                      │
│                            │             │                      │
│                            ▼             │                      │
│                     ┌──────────────┐    │                      │
│                     │  PrismASR    │────┘                      │
│                     └──────────────┘                           │
│                                                                 │
│ 🧪 测试策略:                                                     │
│ • 每个 Package 独立单元测试                                     │
│ • App Target 集成测试                                          │
│ • CI 并行测试各模块                                            │
│                                                                 │
│ 🛠️ 构建配置:                                                     │
│ • SPM 统一依赖管理                                             │
│ • SwiftLint 代码规范检查                                       │
│ • 最低支持版本: iOS 17.0 / macOS 14.0                          │
└─────────────────────────────────────────────────────────────────┘
                              ↓ 细化（拆解为可执行任务）
┌─────────────────────────────────────────────────────────────────┐
│ 🎯 Task-002: 搭建多平台工程骨架（实现层 - How）                   │
│                                                                 │
│ 📋 任务信息:                                                     │
│ • Sprint: Sprint 0                                             │
│ • Story Points: 5 SP                                           │
│ • 负责人: @developer                                           │
│ • 状态: ✅ Done                                                 │
│                                                                 │
│ 📎 参考文档:                                                     │
│ • HLD v0.2 §13 工程结构                                        │
│ • ADR-0001 多平台架构决策                                      │
│                                                                 │
│ 🔧 详细执行步骤:                                                 │
│ 1️⃣ 创建 Workspace                                               │
│    $ mkdir -p Prism-xOS && cd Prism-xOS                       │
│    $ xcodebuild -createworkspace -workspace PrismPlayer.xcworkspace
│                                                                 │
│ 2️⃣ 创建 Swift Packages                                          │
│    $ mkdir -p packages/{PrismCore,PrismASR,PrismKit}          │
│    $ cd packages/PrismCore && swift package init --type library
│    # 重复为其他 package                                        │
│                                                                 │
│ 3️⃣ 创建 App Targets                                             │
│    # 使用 Xcode 创建 iOS/macOS 应用，配置依赖                  │
│    # Package.swift 添加产品声明                                │
│                                                                 │
│ 4️⃣ 集成 SwiftLint                                               │
│    $ brew install swiftlint                                    │
│    # 配置 .swiftlint.yml 严格模式                              │
│    # 添加 Build Phase Script                                  │
│                                                                 │
│ 5️⃣ 配置 CI                                                      │
│    # 创建 .github/workflows/ci.yml                             │
│    # 添加 xcodebuild test 命令                                 │
│                                                                 │
│ ✅ 验收标准 (AC):                                                │
│ - [ ] Workspace 包含 3 个 Package 和 2 个 App                  │
│ - [ ] 每个 Package 可独立编译                                  │
│ - [ ] SwiftLint 无 error（warning < 5）                        │
│ - [ ] CI 通过所有单元测试                                      │
│ - [ ] README 包含构建说明                                      │
│                                                                 │
│ ⚠️ 依赖与风险:                                                   │
│ • Xcode 16.0+ 必需                                             │
│ • Swift 6.0 语法迁移可能需要额外时间                            │
└─────────────────────────────────────────────────────────────────┘
```

**文档流转说明**：
1. **ADR** 记录决策历史（不可变） → 为未来维护者解释"为什么当初这样选"
2. **HLD** 定义系统架构（可演进） → 为开发团队提供全局视图
3. **Task** 指导具体实现（Sprint 内） → 为执行者提供操作手册

**引用链路**：
```
Task-002 → HLD §13 → ADR-0001
  ↑          ↑          ↑
怎么做？   是什么？   为什么？
```

## Task 设计文档模板示例

````markdown
# Task-102: AsrEngine 协议定义与 WhisperCpp 后端实现

## 任务信息
- **Sprint**: Sprint 1
- **PBI**: AsrEngine 协议定义与 WhisperCppBackend（5 SP）
- **负责人**: @developer-name
- **状态**: In Progress / Review / Done
- **相关文件**:
  - `packages/PrismASR/Sources/AsrEngine.swift`
  - `packages/PrismASR/Sources/WhisperCppBackend.swift`
  - `packages/PrismASR/Tests/AsrEngineTests.swift`

## 设计目标
实现 AsrEngine 协议抽象，完成 whisper.cpp 后端集成，支持 gguf 模型加载与离线推理。

## 技术方案

### 1. 协议定义
```swift
// filepath: packages/PrismASR/Sources/AsrEngine.swift
public protocol AsrEngine {
    func transcribe(
        audioData: Data,
        options: AsrOptions
    ) async throws -> [AsrSegment]
}

public struct AsrOptions {
    let language: AsrLanguage?
    let enableTimestamps: Bool
    // ...
}
```

### 2. Whisper.cpp 集成策略
- 使用 SPM 包装或直接依赖
- Metal/Accelerate 后端自动选择
- 模型路径与加载策略

### 3. 测试策略
- 协议契约测试（Mock Backend）
- 金样本回归（3 段音频 × 10-30s）
- 性能基线记录

## 验收标准 (AC)
- [ ] AsrEngine 协议定义完成
- [ ] WhisperCppBackend 实现通过单测
- [ ] 金样本 WER < 15%
- [ ] 文档与示例代码完整

## 依赖与风险
- whisper.cpp 版本锁定
- Metal 兼容性测试（iOS 17+ / macOS 14+）

## 参考
- HLD §6.1/§6.2
- whisper.cpp 官方文档
````

## 关键原则



 

### 1. 三层设计原则（分层递进）

文档设计遵循 **Why → What → How** 的三层递进结构：

```
                      抽象度
                        ↑
    ┌──────────────────────────────────────┐
    │  PRD (Product)                       │  产品层：做什么 + 为何做
    │  What + Why (from Product View)     │
    └──────────────────────────────────────┘
              ↓ 技术可行性分析
    ┌──────────────────────────────────────┐
    │  ADR (Decision)                      │  决策层：为何这样设计
    │  Why (from Tech View)                │  ├─ 关键技术选型
    └──────────────────────────────────────┘  └─ 架构重大决策
              ↓ 引用获取详细设计                    ↓
    ┌──────────────────────────────────────┐
    │  HLD/TDD (Architecture)              │  架构层：是什么 + 概要如何
    │  What + How (Overview)               │  ├─ 系统整体架构
    └──────────────────────────────────────┘  ├─ 模块职责划分
              ↓ 拆解为可执行任务                  └─ 核心接口设计
    ┌──────────────────────────────────────┐      ↓
    │  Task Design (Implementation)        │  实现层：具体如何做
    │  How (Detailed)                      │  ├─ 代码实现方案
    └──────────────────────────────────────┘  ├─ 测试验收标准
                                              └─ 步骤时序安排
                      具体度
                        ↓
```

**各层职责总结**：

| 文档类型 | 核心问题 | 主要内容 | 负责人 | 生命周期 |
|---------|---------|---------|--------|---------|
| **PRD** | 做什么？为何做？<br>(What & Why - Product) | 用户故事、功能清单、<br>验收标准、成功指标 | PM/产品经理 | 长期维护（版本化） |
| **ADR** | 为何这样设计？<br>(Why - Tech) | 决策过程、方案对比、<br>选择理由、预期影响 | 架构师/Tech Lead | 永久保留（不可变） |
| **HLD** | 是什么？概要怎么做？<br>(What & How Overview) | 架构设计、模块划分、<br>接口定义、技术栈 | Tech Lead/架构师 | 长期维护（版本化） |
| **Task** | 具体怎么做？怎么验证？<br>(How Detailed) | 代码实现、步骤拆解、<br>测试用例、AC 清单 | 开发工程师 | Sprint 周期内 |

**关键原则**：
- **向上引用**：Task → HLD → ADR → PRD（获取背景和依据）
- **向下细化**：PRD → ADR → HLD → Task（逐层具体化）
- **避免重复**：每层只写属于自己抽象度的内容
- **保持一致**：下层实现必须符合上层设计

### PRD vs TDD/HLD 职责边界

PRD 文档应该聚焦于"做什么"（What）和"为什么"（Why），而不是"怎么做"（How）。架构图、线程模型、DI 策略等属于**技术设计文档（Technical Design Document, TDD）**的范畴，不应该出现在 PRD 中。


| 文档类型 | 核心职责 | 典型内容 | 负责人 |
|---------|---------|---------|--------|
| **PRD** | 定义产品需求 | 用户故事、功能列项、验收标准、成功指标 | PM/产品经理 |
| **TDD** | 定义技术方案 | 架构设计、API 设计、数据模型、技术选型细节 | 技术负责人/架构师 |

### 2. ADR 写作规范

**✅ 应该包含的内容**：
- 问题陈述（1-2 段，清晰描述需要决策的场景）
- 决策驱动因素（业务、技术、团队约束）
- 2-3 个备选方案的对比表格（简明扼要）
- 决策结果与关键理由
- 预期影响（正面/负面后果）
- 引用 HLD/PRD 获取详细设计

**❌ 不应该包含的内容**：
- 完整代码实现（超过 20 行的代码块）
- 详细的类图/时序图（应放在 HLD 中）
- 配置步骤和操作指南（应放在 Task 或 README）
- 与决策无关的背景知识

**示例对比**：

| ❌ ADR 中不恰当的内容 | ✅ 应该出现的位置 |
|---------------------|-----------------|
| 完整的目录树结构（50+ 行） | HLD §13 工程结构 |
| SwiftLint 配置步骤 | Task-002 或 README |
| 测试框架完整使用教程 | HLD §10 测试策略 |
| 所有 Mock 类的实现 | 代码仓库 Tests/Mocks/ |

### 3. 可追溯性原则

- **Task 设计**必须关联 PBI 与 Sprint
- **ADR** 需引用相关 PRD/HLD 章节号
- **HLD** 需引用关键决策的 ADR 编号
- 使用双向链接：`📎 详细设计见 HLD v0.2 §6.1` ↔ `📎 决策依据见 ADR-0003`

### 4. 生命周期管理

- **Task 设计**：Sprint 结束后归档到 `tasks/sprint-N/`
- **ADR**：永久保留，废弃时标记状态为 `Superseded by ADR-XXXX`
- **HLD**：版本化管理（v0.1, v0.2...），重大变更时创建新版本
- **通用设计**：从 Task 提取，合并回 HLD（长期维护）

### 5. 文件命名规范

- **ADR**: `<4位编号>-<短横线分隔描述>.md`（如 `0001-multiplatform-architecture.md`）
- **Task**: `task-<编号>-<简短描述>.md`（如 `task-102-asr-engine-protocol.md`）
- **HLD**: `hld-<平台>-<版本>.md`（如 `hld-ios-macos-v0.2.md`）
- **PRD**: `prd_<版本>.md`（如 `prd_v0.2.md`）

## 文档审查清单

### ADR 审查检查项

在提交 ADR 前，确认以下事项：

- [ ] **标题清晰**：能从标题直接看出决策主题
- [ ] **状态明确**：标注当前状态（提议中/已接受/已废弃/已替代）
- [ ] **问题陈述完整**：清楚说明需要决策的场景和约束
- [ ] **方案对比充分**：至少有 2 个备选方案，且对比维度明确
- [ ] **理由充分**：说明为什么选择此方案，而不是其他方案
- [ ] **影响分析**：列出预期的正面和负面后果
- [ ] **引用明确**：相关 PRD/HLD 章节有明确链接
- [ ] **内容精简**：没有冗长的代码实现或配置步骤
- [ ] **永久性**：内容是决策历史记录，不会频繁修改

### HLD 审查检查项

- [ ] **架构完整**：系统组件、分层、数据流都有说明
- [ ] **接口清晰**：关键协议和接口有定义
- [ ] **技术栈明确**：框架、库、工具链有说明
- [ ] **非功能需求**：性能、安全、可测试性有考虑
- [ ] **平台差异**：iOS/macOS 特定部分有明确标注
- [ ] **ADR 引用**：关键设计有引用对应的决策记录
- [ ] **版本标识**：文档版本号与 PRD 版本对应

### Task 设计审查检查项

- [ ] **关联明确**：关联的 Sprint 和 PBI 编号正确
- [ ] **目标清晰**：能明确知道这个 Task 要实现什么
- [ ] **验收标准具体**：AC 清单可执行、可验证
- [ ] **技术方案详细**：包含代码示例、配置说明
- [ ] **测试策略**：说明如何测试和验证
- [ ] **依赖识别**：列出前置依赖和潜在风险
- [ ] **参考完整**：引用相关的 HLD 章节和文档

## 常见问题 FAQ

### Q1: 某个技术决策应该写 ADR 还是直接写在 HLD 里？

**判断标准**：
- 如果是**有争议的、有多个备选方案的、未来可能被质疑的**决策 → **写 ADR**
- 如果是**显而易见的、行业标准的、团队共识的**选择 → **直接写 HLD**

**示例**：
- ✅ ADR: "为什么选 Swift Package 而不是 CocoaPods"（有争议）
- ❌ ADR: "为什么用 Swift 而不是 Objective-C"（显而易见）
- ✅ ADR: "为什么用协议式 DI 而不是依赖注入框架"（有多个方案）
- ❌ ADR: "为什么用 Git 做版本管理"（行业标准）

### Q2: ADR、HLD、Task 内容重复怎么办？

**解决方案**：三层文档各司其职，通过引用避免重复
- **ADR** 只写**决策过程**（为什么），用简表对比方案，不含详细架构
- **HLD** 写**设计结果**（是什么），用详图描述架构，不含实现细节
- **Task** 写**实现细节**（怎么做），包含代码示例，不重复架构说明

**互相引用**：
- ADR 末尾：`📎 详细设计见 HLD v0.2 §X.X`
- HLD 对应章节：`📎 决策依据见 ADR-00XX`
- Task 开头：`📎 参考 HLD v0.2 §X.X 和 ADR-00XX`

**示例对比**：

| 内容 | ADR | HLD | Task |
|------|-----|-----|------|
| 为什么选 Workspace | ✅ 完整对比表 | ❌ 只引用 ADR | ❌ 只引用 ADR |
| 目录结构设计 | ⚠️ 简略说明 | ✅ 完整结构 + 依赖图 | ⚠️ 只引用 HLD |
| Package.swift 配置 | ❌ 不涉及 | ⚠️ 接口级示例 | ✅ 完整配置代码 |
| xcodebuild 命令 | ❌ 不涉及 | ❌ 不涉及 | ✅ 完整执行步骤 |

### Q3: Sprint Task 设计文档要写多详细？

**原则**：
- **足够详细**以便其他开发者接手或 Code Review
- **不过度设计**，避免写成完整的技术手册
- **以实现为导向**，重点是"怎么做"而不是"为什么"

**建议长度**：
- 简单 Task（1-2 SP）：1-2 页，简要方案 + AC
- 中等 Task（3-5 SP）：2-4 页，详细方案 + 测试策略
- 复杂 Task（8+ SP）：考虑拆分，或写 4-6 页设计文档

**判断是否需要 Task 详细设计**：

| 场景 | 是否需要详细设计 | 原因 |
|------|----------------|------|
| 简单 UI 调整（改颜色、字号） | ❌ 不需要 | 直接在 PBI 描述即可 |
| 新增一个简单页面（无复杂逻辑） | ⚠️ 可选 | 如果团队新人多，建议写 |
| 实现新的核心模块（如 AsrEngine） | ✅ 必须 | 涉及架构设计、接口定义 |
| 集成第三方 SDK | ✅ 必须 | 需要记录配置步骤、坑点 |
| 性能优化任务 | ✅ 必须 | 需要 Baseline、测试策略 |
| Bug 修复 | ❌ 通常不需要 | 在 Bug Ticket 描述即可 |

### Q4: 什么时候需要更新文档？

| 场景 | 需要更新的文档 | 操作方式 |
|------|--------------|----------|
| 需求变更 | PRD | 版本升级（v0.2 → v0.3） |
| 架构调整 | HLD | 更新对应章节，记录变更日期 |
| 决策废弃 | ADR | 标记状态为 `Superseded by ADR-XXXX` |
| 实现完成 | Task | 更新状态为 Done，归档到 `tasks/sprint-N/` |
| 新的重要决策 | ADR | 创建新的 ADR-XXXX.md |
| Task 实现中发现架构问题 | HLD + 可能需要新 ADR | 先修改 HLD，如涉及决策变更则创建新 ADR |

**重要**：ADR 原则上不修改，只能通过新 ADR 替代旧 ADR。

### Q5: Task 实现时发现 HLD 设计有问题怎么办？

**处理流程**：
1. **评估影响范围**：
   - 只影响当前 Task → 在 Task 中记录偏差，Sprint Review 时更新 HLD
   - 影响多个模块 → 立即暂停，组织技术评审

2. **文档更新顺序**：
   ```
   发现问题 → 技术评审 → 是否涉及重大决策变更？
                            ├─ 是 → 创建新 ADR → 更新 HLD → 更新 Task
                            └─ 否 → 直接更新 HLD → 更新 Task
   ```

3. **典型场景**：
   - **接口设计不合理**：更新 HLD 接口章节，Task 按新设计实现
   - **技术选型错误**（如 whisper.cpp 性能不达标）：创建新 ADR 替代旧决策，更新 HLD，重新设计 Task
   - **实现细节优化**（如算法改进）：只在 Task 中记录，不更新 HLD

### Q6: 如何处理跨平台差异的文档？

**原则**：共性写在统一文档，差异写在平台专属文档

**示例**：

| 内容类型 | 文档位置 | 说明 |
|---------|---------|------|
| 共同的产品需求 | `docs/requirements/prd_v0.2.md` | 单一 PRD，标注平台差异 |
| 共同的架构决策 | `docs/adr/0001-xxx.md` | 跨平台 ADR 放在 `adr/` 根目录 |
| iOS 特有决策 | `docs/adr/iOS-macOS/0002-xxx.md` | 平台特定 ADR 放在子目录 |
| Android 特有决策 | `docs/adr/Android/0001-xxx.md` | 平台特定 ADR 放在子目录 |
| iOS/macOS HLD | `docs/tdd/iOS-macOS/hld-ios-macos-v0.2.md` | 平台专属 HLD |
| Android HLD | `docs/tdd/Android/hld-android-v0.2.md` | 平台专属 HLD |
| iOS Task | `docs/scrum/iOS-macOS/tasks/sprint-1/task-xxx.md` | 平台专属 Task |

**PRD 中标注平台差异示例**：
```markdown
### 功能 3.2：实时字幕显示

**通用需求**：
- 字幕自动滚动，保持当前播放位置在视野中
- 支持字幕字号调整（小、中、大）

**平台差异**：
- **iOS**：字幕悬浮在视频上方，支持手势拖动位置
- **macOS**：字幕默认显示在视频下方独立区域，支持分离窗口
```

### Q7: 如何确保 Task 实现符合 HLD 设计？

**Code Review 检查清单**：
- [ ] Task 引用的 HLD 章节是否正确
- [ ] 实现的接口是否符合 HLD 定义
- [ ] 模块依赖关系是否符合 HLD 架构图
- [ ] 命名规范是否符合 HLD 约定
- [ ] 测试策略是否覆盖 HLD 提出的非功能需求

**自动化检查**（可选）：
- **架构测试**：使用工具（如 SwiftLint custom rules）检查模块依赖
- **接口一致性测试**：协议测试确保实现符合定义
- **文档同步检查**：CI 检查 Task 状态与代码提交的一致性

---

## 总结

本项目采用**四层文档体系**，清晰分离产品、决策、架构、实现四个层面，支持敏捷迭代：

```
┌─────────────────────────────────────────────────────────────┐
│                    文档体系总览                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  PRD (产品需求) ──→ ADR (关键决策) ──→ HLD (架构设计) ──→ Task (实现细节)
│       ↓                  ↓                  ↓                ↓
│    做什么？            为什么？            是什么？          怎么做？
│    Why (产品)          Why (技术)         What + How概要    How详细
│       │                  │                  │                │
│  产品视角            技术选型            架构设计          代码实现
│  永久维护            永久保留            长期维护          Sprint周期
│   版本化              不可变              版本化            完成归档
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 核心设计原则

**1. 分层递进**：每层文档专注于特定抽象级别，避免重复
   - PRD 不涉及技术实现
   - ADR 不包含详细架构
   - HLD 不包含具体代码
   - Task 不重复架构说明

**2. 双向引用**：文档间通过引用建立可追溯性
   ```
   Task → HLD → ADR → PRD  (向上追溯：为什么这样做？)
   PRD → ADR → HLD → Task  (向下细化：具体怎么做？)
   ```

**3. 生命周期分离**：不同文档有不同的维护策略
   - **永久保留**：ADR（决策历史）
   - **长期维护**：PRD、HLD（版本化演进）
   - **周期归档**：Task（Sprint 结束后归档）

**4. 模板驱动**：所有文档类型都有标准模板（`docs/template/`）

### 文档协同工作流程

```
┌─────────────┐
│ 1. 需求阶段  │  编写/更新 PRD
└──────┬──────┘
       ↓
┌─────────────┐
│ 2. 设计阶段  │  根据 PRD 编写 HLD
└──────┬──────┘  遇到关键技术选择时创建 ADR
       ↓
┌─────────────┐
│ 3. 迭代阶段  │  根据 HLD 拆分 Sprint
└──────┬──────┘  为复杂 Task（3+ SP）创建详细设计
       ↓
┌─────────────┐
│ 4. 实现阶段  │  参考 Task 设计文档实现功能
└──────┬──────┘  必要时更新 HLD（如发现设计问题）
       ↓
┌─────────────┐
│ 5. Review   │  检查代码与设计文档一致性
└──────┬──────┘  验证 AC 完成情况
       ↓
┌─────────────┐
│ 6. 归档阶段  │  Sprint 结束后归档 Task 文档
└──────┬──────┘  总结经验更新 HLD
       ↓         提取通用模式补充到 ADR
     (循环)
```

### 快速决策指南

**我该写哪个文档？**

| 你的问题 | 应该写的文档 | 理由 |
|---------|------------|------|
| 用户需要什么功能？ | PRD | 产品需求定义 |
| 为什么选这个技术方案？ | ADR | 关键决策记录 |
| 系统整体架构是什么样的？ | HLD | 架构设计 |
| 这个 Task 具体怎么实现？ | Task 详细设计 | 实现指导 |
| 为什么当初这样设计？ | 查阅 ADR | 决策历史查询 |
| 某个模块职责是什么？ | 查阅 HLD | 架构文档查询 |

### 文档质量保证

每类文档都有对应的审查清单（见上文各部分），确保：
- ✅ 结构完整（符合模板要求）
- ✅ 引用正确（相关文档已链接）
- ✅ 内容适度（不过于简略或冗长）
- ✅ 可追溯性（决策有依据，实现有指导）

---

**记住**：好的文档不是写得多，而是**写在正确的地方、正确的抽象层次**。