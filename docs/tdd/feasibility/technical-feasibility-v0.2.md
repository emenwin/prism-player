# Prism Player 技术可行性分析（TFA）

> 版本：v0.2 对应 PRD v0.2  • 日期：2025-10-17  • 文档定位：评估“能否做、怎么做、成本与风险”，不含具体实现代码。

## 0. 结论摘要

- 整体可行：基于端侧 ASR（优先 whisper.cpp/CT2/faster-whisper 路线）与平台原生播放器（iOS AVFoundation / Android ExoPlayer）可满足 PRD 目标。
- KPI 达成：
  - 高端机（近两年旗舰）在 tiny/base 量化模型（q5/q6/int8）下可达 RTF ≥ 1.0，首帧字幕 ≤ 5–8s 可实现；
  - 中端机 RTF ≈ 0.5（base.q5 / tiny.en.int8），通过预加载与抢占识别满足“边播边出字”；
  - 入门机以 tiny/tiny.en 量化为主，首帧与滚动延迟较高，但在 PRD 容差范围内可通过占位与降级提示满足体验基线。
- 关键约束与对策：
  - 背景持续识别：iOS 受系统限制（除音频播放后台与 BGProcessingTask 外），Android 需前台服务。对策：播放中允许后台；非播放状态使用任务化识别与用户提示。
  - 资源占用：模型体积 30–250MB（量化后），运行期内存 150–400MB（按模型/窗口而异）。对策：默认小模型、分块推理、限制上下文窗口与缓存上限（10MB 音频缓存可行）。
  - 许可与分发：优先选择 MIT/BSD 等宽松许可方案（whisper.cpp/CT2 均可），模型下载采用用户触发与校验。
- 分阶段建议与风险缓解与 PRD 里程碑（M1–M3）一致，可在 2–3 个迭代内达成“可用版”，再进入性能与能耗优化期。

---

## 1. 范围与目标映射

- 范围：评估 PRD v0.2 In-Scope 功能的技术路径、平台能力、性能可达性、风险与对策。
- 目标映射：
  - 本地播放与音频滚动提取 → 原生播放器 + 自研音频抽头（tap）链路；
  - 端侧 ASR → whisper.cpp/CT2（faster-whisper）嵌入式推理；
  - 字幕生成/渲染/导出 → 本地时间戳片段存储 + UI 渲染 + SRT/VTT 生成；
  - 模型管理、缓存与设置 → 本地安全存储 + 下载/导入/删除流程；
  - i18n/a11y、隐私与后台行为 → 平台能力评审与对策。

## 2. 技术架构方案

- 客户端分层（MVVM）：
  - UI 层：
    - iOS SwiftUI / Android Jetpack Compose。
  - 业务层（ViewModel + UseCase）：
    - 播放控制、识别编排、抢占与节流、样式与导出。
  - 服务层（模块）：
    - 媒体播放（PlayerService）：AVPlayer/ExoPlayer 封装（进度、倍速、拖动）。
    - 音频抽取（AudioExtractService）：按窗口滚动解码 PCM（16kHz/mono/16-bit）。
    - ASR 引擎（AsrEngine）：whisper.cpp 或 CT2（faster-whisper）封装（流式/分段）。
    - 字幕存储（SubtitleStore）：分段结果（start/end/text/confidence）与窗口索引。
    - 模型管理（ModelManager）：下载/导入/校验/版本/清理。
    - 缓存管理（CacheManager）：音频片段与中间产物（LRU，≤10MB）。
    - 导出（ExportService）：SRT 必选、VTT 可选。
    - 诊断与本地指标（MetricsService）：离线统计与问题反馈包。
  - 原生桥接：
    - 引擎采用 C/C++/CMake 构建（whisper.cpp/CT2），通过 Swift/Kotlin 封装轻量 API。

- 数据流（播放-识别-渲染闭环）：
  1) 选择媒体 → 解析轨道 → 初始化播放器；
  2) 预加载窗口 Tpre（默认 30s）音频 → 转码为 16kHz mono PCM；
  3) 推送到 ASR 引擎进行分段识别（滑窗/流式），生成时间戳片段；
  4) UI 渲染已得片段；缺口区域显示占位；
  5) 播放进度滚动 → 音频滚动提取（每 15–30s 段）与识别；
  6) 拖动进度 → 抢占识别“当前点起后 60s”窗口，队列重排；
  7) 导出 → 汇总所有片段生成 SRT/VTT。

- 轻量“契约”（AsrEngine API 建议）：
  - loadModel(path, options) → ModelHandle
  - transcribe(samples, sampleRate, startTime, options) → [Segment]
  - setLanguage(lang|auto)
  - flush()/resetContext()
  - getProgress() / cancel(jobId)

## 3. 端侧 ASR 技术评估

- 候选方案
  - whisper.cpp（ggml/gguf）：
    - 优点：纯 C/C++、移动端成熟、iOS Metal 加速、体积可控、许可宽松（MIT）。
    - 性能：tiny/base（q5–q8 / int8）在 A15+/骁龙 888+ 可达 RTF ~0.8–1.5；中端 RTF ~0.3–0.8（经验区间，依语言/噪声变化）。
    - 流式：支持分段/滑窗与上下文提示（prompt），可按 15–30s 塞入并合并片段。
  - faster-whisper（CTranslate2 后端）：
    - 优点：int8/int8_float16 高效，ARM NEON 优化，精度与速度折中更好；
    - 难点：移动端集成与体积控制、iOS/Android 交叉编译产物维护成本更高。
  - 备选（兜底）：Vosk/Kaldi-io、ONNXRuntime+Whisper 微型变体（离线可用但精度/性能需实测）。

- 模型体积与语言
  - 参考（量化后近似）：
    - tiny/tiny.en：15–40MB；base/base.en：60–120MB；small：150–300MB（不建议默认）。
  - 建议：默认内置“超轻量 demo 模型”（仅英文），引导用户下载 base/tiny 多语言模型；支持本地导入。

- 时间戳与对齐
  - Whisper 系列原生输出带起止时间片段，满足 ±200ms 目标；
  - 通过“相邻合并 + 断句优化（置信度/标点/间隔阈值）”提升观感。

- 语言检测
  - 引擎自带语言检测（前几秒），精度在嘈杂与短语境下下降；
  - 建议 UI 明示“手动指定语言更快更准”，并持久化用户上次选择。

## 4. 媒体与音频抽取可行性

- iOS：
  - 播放：AVPlayer（倍速、拖动、前后台音频）。
  - 抽取：AVAssetReader 解码音轨 → 转码 16kHz/mono PCM（AudioConverter/AVAudioEngine）；
  - 渠道：可在播放前后台并行抽取（注意会有额外能耗）。
- Android：
  - 播放：ExoPlayer（倍速、拖动、通知栏控制）。
  - 抽取：MediaExtractor + MediaCodec 解码到 PCM；或在 ExoPlayer 旁路使用 AudioSink/AudioProcessor 拿到 PCM（避免重复解码）。
- 精度与同步：
  - 均以播放器当前时间为唯一时钟源；渲染层对显示时长随倍速等比缩放。

## 5. 后台与系统限制

- iOS：
  - 后台播放：启用 Audio 背景模式可保持播放与轻度抽取；
  - 长时间 CPU 密集识别在纯后台可能被系统挂起；
  - 对策：
    - 播放中允许后台继续识别（降优先级与节流）；
    - 非播放状态通过 BGProcessingTask 安排批量识别，并在 UI 说明非即时；
    - 重要任务使用 beginBackgroundTask(withName:) 做短时收尾（数分钟）。
- Android：
  - 使用 Foreground Service + 常驻通知在后台持续识别；
  - 受电量策略影响，需 Battery Optimization 适配与节流；
  - 拖动/跳播后抢占任务优先级，避免无效算力消耗。

## 6. 性能与资源预算（估算）

- 首帧字幕时间（选择媒体→首条字幕）：
  - 路径：I/O（解析）+ 模型加载 + 预加载 30s 抽取 + 首段推理。
  - 优化：
    - 懒加载/共享模型句柄；
    - 先用超短窗口（5–10s）“打通首字”，随后扩窗补齐；
    - I/O 与推理并行流水线（双缓冲队列）。
- RTF（Realtime Factor）：
  - 影响因素：模型大小、量化精度、语言、噪声、设备；
  - 目标：高端≥1.0，中端≥0.5，入门≥0.3；
  - 手段：量化（int8/q5）、减少上下文、禁用转写冗余特性、Metal/NEON 加速。
- 内存：
  - 模型常驻 + 激活内存：100–400MB（tiny→small 量化梯度）；
  - 音频缓存：10MB 上限可行（16kHz/mono/16-bit ≈ 31.25KB/s，300s ≈ 9.4MB）；
  - 对策：严格滑窗、及时释放中间张量、内存警告时仅保留“±15s”。
- 存储：
  - 模型多版本并存需空间提示与一键清理；导出字幕文件几百 KB 级别。
- 能耗与热：
  - 持续推理会升温与降频；
  - 手段：段间节流、后台降速、低电量提示与暂停、强制使用小模型于入门设备。

## 7. 模型管理与分发

- 下载/导入：
  - 展示大小与预计时间，断点续传，校验和校验（SHA256），失败可重试；
  - 存储空间检查与引导清理；
  - 记录版本、语言范围、量化类型、来源与许可信息。
- 状态机：未安装/等待/下载中/校验/失败/已就绪；至少保留一个可用模型。
- 语言选择：自动/手动；提示“手动更快更准”，记住上次选择。

## 8. 字幕生成、渲染与导出

- 生成：
  - 以固定/自适应段长输出，支持相邻合并（间隔阈值、标点与置信度）；
  - 失败段标记并可重试；按窗口增量落盘，避免长视频内存膨胀。
- 渲染：
  - 以播放器当前时间戳匹配片段；缺口显示“加载中…”占位；
  - 倍速适配：显示时长与速度等比；识别明显落后时给出提示。
- 导出：
  - SRT 必选、VTT 可选；UTF-8；命名 <源文件名>.<locale>.srt；
  - 导出前空间检查；失败可重试；避免覆盖源媒体。

## 9. 平台实现要点

- iOS：
  - 框架：AVFoundation、AVAssetReader、AudioConverter/AVAudioEngine、BackgroundTasks、Metal；
  - SwiftUI + MVVM；严格 SwiftLint；
  - 文件访问：UIDocumentPicker/文件权限描述；
  - 本地存储：FileManager + SQLite（可选）/Core Data（仅索引）。
- Android：
  - 框架：ExoPlayer、MediaExtractor/MediaCodec、WorkManager、Foreground Service、NDK（CMake）；
  - Jetpack Compose + MVVM；
  - 文件访问：Storage Access Framework（SAF）；
  - 本地存储：Room/SQLite；
  - NDK 集成引擎（whisper.cpp/CT2）。

## 10. 隐私、合规与国际化/无障碍

- 隐私：
  - 默认离线；不上传媒体与字幕；本地可一键清理缓存与模型。
- 许可：
  - 依赖库与模型在“关于”页披露；选择 MIT/BSD 等宽松许可组件；
  - 模型来源与条款在下载/导入时提示。
- i18n：
  - 禁用硬编码字符串；首期中英双语；日期/数字/方向性依系统区域。
- a11y：
  - 动态字体、颜色对比、屏幕阅读器可读控件与状态；
  - 朗读字幕与原音频冲突风险，提供显式开关且默认关闭。

## 11. 失败与错误处理

- 统一状态：等待/进行/成功/失败；轻量提示不遮挡内容。
- 错误分类与对策：
  - 媒体不支持 → 明确提示并建议转码；
  - 空间不足 → 引导清理模型/缓存；
  - 模型缺失/损坏 → 重下/校验重试；
  - 权限拒绝 → 解释性引导；
  - 后台受限 → 说明策略与恢复入口。
- 诊断包：配置、设备与版本、关键时序、错误码（脱敏，不含媒体）。

## 12. 开发成本与里程碑映射（2–4 周/迭代）

- M1 原型：
  - 播放、预加载抽取、最小模型离线识别、基础渲染、SRT 导出；
  - 风险：引擎编译与桥接打通、首帧时间调优；
- M2 可用版：
  - 增量识别与滚动字幕、模型管理（下载/导入/删除）、语言选择、缓存管理、倍速适配、VTT；
  - 风险：下载中断/校验、缓存与内存压力策略、i18n/a11y 覆盖；
- M3 优化版：
  - 进度拖动抢占识别、质量感知与按段重识别、后台行为完善、能耗与性能优化、错误码体系与稳定性。

## 13. 风险清单与缓解

- 性能不足（低端设备）：默认小模型、限窗、节流、占位与提示；提供切换更快模型与倍速建议。
- 背景限制（iOS）：播放中后台可行；非播放使用 BGProcessingTask；向用户明确“非实时”。
- 存储压力：下载前大小提示与空间检查；模型一键清理；保留至少一个可用模型。
- 语言检测误差：允许手动指定语言并持久化；可选基于最近选择推荐。
- 稳定性与热：分段推理、降频/降速策略；长期任务分块；崩溃监控与内存警告处理。
- 许可合规：第三方清单与版本记录；模型来源与哈希校验；不内置大模型。

## 14. 开放问题（需在 TDD/HLD 中收敛）

- 引擎选型最终落地（whisper.cpp vs CT2/faster-whisper）与双引擎开关成本评估。
- iOS Metal/Core ML 加速路径与收益对比；Android NEON/Vulkan 可用性与维护成本。
- 细化“抢占识别”调度策略（优先级、队列、公平性）。
- 断句合并与置信度阈值的默认参数与可配置范围。
- 本地数据模型与迁移方案（版本化 Schema 与回退策略）。

## 15. 结论

在遵循“默认小模型、滑窗流式、严格资源与后台策略”的前提下，Prism Player 的端侧离线字幕能力在 iOS 与 Android 上具备良好技术可行性。通过分阶段迭代（M1→M3）与针对性优化，可达到 PRD 的功能与性能目标，并在隐私与合规、i18n/a11y 上满足首期要求。