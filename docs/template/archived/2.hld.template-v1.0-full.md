<!-- 
模板名称：HLD 高层设计文档
适用场景：系统/模块的详细设计，模块划分和交互设计
填写指南：
  - 🔴 必填项：第 1-5 节（背景、需求、模块设计、数据设计、接口设计）
  - 🟡 可选项：第 7-9 节（根据项目复杂度决定）
  - ⏱️ 预估耗时：4-6 小时
  - 📝 Review 检查清单：模块职责清晰、依赖关系明确、接口契约完整、数据流清晰
文档分层：
  - 上游：ADD（架构设计） - 定义整体架构风格和技术选型
  - 本层：HLD（高层设计） - 定义模块划分和交互方式
  - 下游：TDD（详细设计） - 定义具体实现逻辑和代码结构
-->

# 高层设计文档（HLD）

> **文档类型**: 高层设计文档  
> **版本**: vX.Y  
> **最后更新**: YYYY-MM-DD  
> **维护人**: @[负责人]  
> **状态**: [Draft | Review | Approved | Deprecated]

---

## 文档关联

**上游文档**：
- **ADD**: `docs/1_design/architecture/add-[name]-vX.Y.md`（架构设计）
- **ADR**: 
  - ADR-000X [标题](链接) — 状态：Accepted — 影响：[一句话]
  - ADR-000Y [标题](链接) — 状态：Proposed — 影响：[一句话]
- **PRD**: `docs/0_prd/prd_vX.Y.md`（产品需求）

**本文档范围**：
- ✅ 模块划分与职责
- ✅ 模块间依赖关系
- ✅ 接口契约定义（协议签名）
- ✅ 数据模型与数据流
- ✅ 关键业务流程
- ❌ 架构风格选择（见 ADD）
- ❌ 具体代码实现（见 TDD）

**下游文档**：
- **TDD**: `docs/1_design/tdd/[module]/tdd-[name]-vX.Y.md`（详细技术设计）

---

## 文档修订历史

| 版本 | 日期 | 作者 | 变更说明 | 关联 TDD/Task |
|------|------|------|---------|--------------|
| v0.1 | YYYY-MM-DD | [作者] | 初始版本 | - |
| v0.2 | YYYY-MM-DD | [作者] | [变更内容] | TDD-XXX, Task-YYY |

---

## 1. 背景与目标

### 1.1 设计背景

[从 PRD 和 ADD 提炼的设计背景]

**业务背景**：
- [描述项目背景、业务场景]
- [现有问题或痛点]

**架构决策依据**：
[引用 ADD 中的相关决策，不重复描述]
- **架构风格**: [如：模块化分层架构] → 详见 ADD 第 4.1 节
- **技术选型**: [如：whisper.cpp + MVVM] → 详见 ADD 第 5 节
- **质量属性**: [优先级：性能 > 隐私 > 可维护性] → 详见 ADD 第 2.2 节

### 1.2 设计目标

[从 ADD 细化到模块级别的具体目标]

**功能目标**：
- 实现 [具体功能]，支持 [具体场景]
- 支持 [可量化的指标]

**质量目标**：

| 质量属性 | 具体指标 | 测量方式 | 验收标准 |
|---------|---------|---------|---------|
| 性能 | 转写延迟 < 100ms (P95) | 性能测试 | ✅ 必须达标 |
| 可靠性 | 崩溃率 < 0.1% | Crash 上报 | ✅ 必须达标 |
| 可维护性 | 测试覆盖率 ≥ 80% | 代码覆盖率 | ⚠️ 迭代提升 |

### 1.3 设计范围

**范围内**：
- [本次设计覆盖的模块/功能]
- [具体的用户场景]

**范围外**（明确不包含）：
- [暂不实现的功能]
- [未来版本的功能]

### 1.4 约束与前提

**技术约束**：
- 平台限制：[如 iOS 16+, Android 8+]
- 依赖约束：[如依赖 whisper.cpp v1.5+]
- 性能约束：[如内存 < 150MB]

**业务约束**：
- 时间约束：[如 Sprint 2 完成]
- 资源约束：[如 2 名开发人员]

**假设前提**：
- [ ] 架构设计（ADD）已完成并评审通过
- [ ] 技术可行性已验证（见 `docs/1_design/feasibility/`）
- [ ] [其他前提条件]

---

## 2. 需求概览

### 2.1 功能需求梳理

[从 PRD 提炼，聚焦本次设计涉及的功能]

| 需求ID | 功能描述 | 优先级 | 涉及模块 | 验收标准 |
|--------|---------|--------|---------|---------|
| FR-001 | [功能描述] | P0 | [模块名] | [可测试的标准] |
| FR-002 | [功能描述] | P1 | [模块名] | [可测试的标准] |

**需求详情**：见 PRD `docs/0_prd/prd_vX.Y.md`

### 2.2 非功能需求

| 类型 | 指标 | 目标值 | 测量方式 | 负责模块 |
|------|------|--------|---------|---------|
| 性能 | 转写延迟 | < 100ms (P95) | 性能监控 | PrismASR |
| 性能 | UI 响应时间 | < 16ms (60fps) | Frame Profiler | PrismKit |
| 可靠性 | 崩溃率 | < 0.1% | Crashlytics | 所有模块 |
| 可维护性 | 测试覆盖率 | ≥ 80% | Coverage Report | 所有模块 |

### 2.3 关键用例

[描述核心用户旅程，用于指导模块设计]

**用例 1：实时转写流程**

```
用户操作：播放视频 → 启动转写
    ↓
系统流程：
[PlayerView] → 触发转写请求
    ↓
[ASRService] → 提取音频流
    ↓
[WhisperEngine] → 执行转写
    ↓
[SubtitleManager] → 字幕同步
    ↓
[SubtitleView] → 显示字幕
```

**用例 2：离线转写流程**

[描述另一个关键用例]

**异常用例**：
- 模型未下载 → 提示下载
- 转写失败 → 重试机制
- 内存不足 → 降级处理

---

## 3. 系统设计概览

> **注意**：本节聚焦模块划分，不包含架构风格选择（见 ADD）

### 3.1 架构决策引用

[引用 ADD 中的相关架构决策，不重复描述]

**相关 ADR**：
- **ADR-0001** [模块化架构](链接) - 采用模块化分层架构
- **ADR-0002** [MVVM 模式](链接) - UI 层使用 MVVM
- **ADR-0003** [ASR 引擎](链接) - 选择 whisper.cpp

**架构约束**（来自 ADD）：
- 分层原则：上层依赖下层，禁止反向依赖
- 抽象原则：依赖协议而非具体实现
- 模块独立：每个模块可独立测试和部署

### 3.2 模块总览

[展示主要模块及其关系，C4 Component 视图]

```
┌─────────────────────────────────────────────────────────┐
│                  Application Layer                       │
│           (PrismPlayer iOS/macOS/Android)                │
└───────────────┬─────────────────────────────────────────┘
                │
    ┌───────────┼───────────┬─────────────┐
    │           │           │             │
    ▼           ▼           ▼             ▼
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌──────────┐
│PrismKit │ │PrismASR │ │PrismCore│ │PlayerCore│
│(UI组件) │ │(语音识别)│ │(基础层) │ │(播放器)  │
└────┬────┘ └────┬────┘ └────┬────┘ └────┬─────┘
     │           │           │            │
     └───────────┴───────────┴────────────┘
                     │
                     ▼
            ┌────────────────┐
            │Platform Services│
            │(iOS/Android API)│
            └────────────────┘
```

**模块概要**（详细设计见第 4 节）：

| 模块 | 职责概述 | 依赖 | 被依赖 |
|------|---------|------|--------|
| PrismCore | 协议定义、数据模型 | 无 | 所有模块 |
| PrismASR | 语音识别封装 | PrismCore | App, PrismKit |
| PrismKit | UI 组件库 | PrismCore | App |
| PlayerCore | 播放器逻辑 | PrismCore | App, PrismKit |
| App | 应用入口和集成 | 所有模块 | 无 |

### 3.3 设计方案对比

[如有多个设计方案，进行对比]

| 方案 | 优点 | 缺点 | 复杂度 | 决策 | ADR 链接 |
|------|------|------|--------|------|---------|
| 方案 A | [优点] | [缺点] | 中 | ✅ 选择 | ADR-XXX |
| 方案 B | [优点] | [缺点] | 高 | ❌ 拒绝 | - |

**选择理由**：[详细说明为什么选择方案 A]

---

## 4. 模块详细设计

> **注意**：本节定义模块职责和接口契约，不包含具体实现（见 TDD）

### 4.1 模块依赖关系

**依赖图**：

```
       ┌─────────┐
       │   App   │
       └────┬────┘
            │ 依赖所有
    ┌───────┼───────┬──────────┐
    │       │       │          │
    ▼       ▼       ▼          ▼
┌────────┐ ┌────┐ ┌────────┐ ┌────────┐
│PrismKit│ │ASR │ │Player  │ │ ...    │
└───┬────┘ └─┬──┘ └───┬────┘ └────────┘
    │        │        │
    └────────┴────────┴──────┐
                              ▼
                        ┌──────────┐
                        │PrismCore │
                        │(基础层)  │
                        └──────────┘
```

**依赖规则表**：

| 模块 | 可依赖 | 禁止依赖 | 说明 | 违反后果 |
|------|-------|---------|------|---------|
| PrismCore | Platform APIs | 任何业务模块 | 基础层，只向下依赖 | 循环依赖 |
| PrismASR | PrismCore | PrismKit, App | 业务逻辑独立 | 耦合度高 |
| PrismKit | PrismCore | PrismASR | UI 不依赖具体业务 | UI 不可复用 |
| App | 所有模块 | - | 应用层集成 | - |

**依赖注入策略**：
- 使用协议（Protocol）定义依赖接口
- 通过构造函数注入依赖
- 避免单例模式（除非必要）

### 4.2 模块职责定义

#### 4.2.1 PrismCore（基础层）

**定位**：提供通用基础能力和抽象协议

**职责**：
- 定义核心数据模型（Subtitle, AudioSegment, MediaInfo 等）
- 定义抽象协议（ASREngine, SubtitleProvider, Player 等）
- 提供工具类（Logger, FileManager, DateFormatter 等）
- 定义错误类型和异常处理机制

**对外接口**（协议签名，不含实现）：

```swift
// 数据模型定义
struct Subtitle {
    let id: UUID
    let startTime: TimeInterval
    let endTime: TimeInterval
    let text: String
    let language: String
    let confidence: Double
}

// 协议定义
protocol ASREngine {
    /// 初始化引擎
    func initialize(config: ASRConfig) async throws
    
    /// 转写音频
    /// - Parameter audio: 音频数据
    /// - Returns: 字幕数组
    func transcribe(audio: AudioData) async throws -> [Subtitle]
    
    /// 取消转写
    func cancel()
}

// 错误定义
enum PrismError: Error {
    case invalidInput(String)
    case operationFailed(String)
    case notSupported(String)
}
```

**不包含**：具体实现逻辑（见 TDD）

**依赖**：无（纯基础层）

**测试策略**：
- 单元测试覆盖率 ≥ 90%
- 所有协议都有 Mock 实现用于测试

#### 4.2.2 PrismASR（语音识别层）

**定位**：封装各类 ASR 引擎实现

**职责**：
- 实现 ASREngine 协议（WhisperEngine, CloudASREngine 等）
- 管理 ASR 模型加载和生命周期
- 处理音频预处理（重采样、降噪等）
- 提供引擎切换和配置管理
- 实现转写任务队列和并发控制

**对外接口**：

```swift
// ASR 服务（Facade 模式）
class ASRService {
    /// 设置 ASR 引擎
    /// - Parameter engine: 引擎实例
    func setEngine(_ engine: ASREngine)
    
    /// 开始转写
    /// - Parameter url: 音频文件 URL
    /// - Returns: 转写进度流
    func startTranscription(for url: URL) -> AsyncThrowingStream<TranscriptionProgress, Error>
    
    /// 取消转写
    func cancelTranscription()
    
    /// 获取可用引擎列表
    func availableEngines() -> [ASREngineInfo]
}

// 进度信息
struct TranscriptionProgress {
    let progress: Double // 0.0 ~ 1.0
    let currentSegment: Subtitle?
    let estimatedTimeRemaining: TimeInterval?
}
```

**依赖**：
- PrismCore（协议和模型）
- Platform APIs（音频处理）

**性能要求**：
- 转写 RTF < 0.3
- 内存占用 < 150MB
- 支持取消和暂停

**详细实现**：见 `TDD-PrismASR-WhisperEngine.md`

#### 4.2.3 PrismKit（UI 组件层）

**定位**：提供跨平台 UI 组件

**职责**：
- 播放器 UI 组件（PlayerView, ControlBar）
- 字幕显示组件（SubtitleOverlay, SubtitleEditor）
- 通用 UI 组件（LoadingView, ErrorView）
- MVVM ViewModel 基类
- UI 主题和样式管理

**对外接口**：

```swift
// SwiftUI 组件（简化示例，不含具体实现）
struct PlayerView: View {
    @ObservedObject var viewModel: PlayerViewModel
    
    var body: some View {
        // UI 布局（详细实现见 TDD）
    }
}

// ViewModel 协议
protocol PlayerViewModel: ObservableObject {
    var playbackState: PlaybackState { get }
    var currentTime: TimeInterval { get }
    var duration: TimeInterval { get }
    var subtitles: [Subtitle] { get }
    
    func play()
    func pause()
    func seek(to time: TimeInterval)
    func toggleSubtitle()
}
```

**依赖**：
- PrismCore（数据模型）
- Platform UI Framework（SwiftUI/Compose）

**设计模式**：
- MVVM（Model-View-ViewModel）
- Observer（数据绑定）
- Delegate（事件回调）

**详细实现**：见 `TDD-PrismKit-PlayerView.md`

#### 4.2.4 [其他模块]

[按需添加其他模块的设计]

### 4.3 模块间交互流程

#### 4.3.1 实时转写流程（时序图）

```sequence
User -> PlayerView: 播放视频
PlayerView -> PlayerViewModel: play()
PlayerViewModel -> PlayerCore: startPlayback()
PlayerViewModel -> ASRService: startTranscription()
ASRService -> WhisperEngine: transcribe(audio)
WhisperEngine --> ASRService: TranscriptionProgress
ASRService --> PlayerViewModel: AsyncStream<Progress>
PlayerViewModel --> PlayerView: 更新 UI (字幕)
PlayerView --> User: 显示字幕
```

**关键步骤说明**：
1. 用户触发播放 → UI 事件
2. ViewModel 协调 → 调用播放和转写服务
3. ASR 服务异步转写 → 返回进度流
4. ViewModel 处理进度 → 更新字幕数据
5. View 响应数据变化 → 显示字幕

**异常处理**：
- 模型未加载 → 提示下载，不阻塞播放
- 转写失败 → 记录错误，继续播放
- 内存不足 → 降级到纯播放模式

#### 4.3.2 字幕同步流程

[描述字幕与播放进度的同步机制]

```
[播放器] --时间更新--> [SubtitleManager]
                           ↓
                    查找当前时间点字幕
                           ↓
                    [SubtitleView] 显示
```

**同步策略**：
- 播放器每 100ms 触发时间更新
- SubtitleManager 使用二分查找匹配字幕
- 缓存最近 N 条字幕，减少查找开销

#### 4.3.3 [其他关键流程]

[根据需要添加]

---

## 5. 数据设计

> **注意**：本节定义数据模型和数据流，不包含具体存储实现（见 TDD）

### 5.1 核心数据模型

#### 5.1.1 实体关系图（ERD）

```
┌─────────────┐         ┌──────────────┐
│   Media     │1      * │   Subtitle   │
│   File      │◄────────│   Segment    │
├─────────────┤         ├──────────────┤
│ id          │         │ id           │
│ url         │         │ mediaId (FK) │
│ duration    │         │ startTime    │
│ format      │         │ endTime      │
│ createdAt   │         │ text         │
└─────────────┘         │ language     │
       │                │ confidence   │
       │                └──────────────┘
       │1
       │
       │*
┌─────────────┐
│Transcription│
│   Job       │
├─────────────┤
│ id          │
│ mediaId(FK) │
│ status      │
│ progress    │
│ createdAt   │
│ completedAt │
└─────────────┘
```

#### 5.1.2 核心实体定义

**Media File（媒体文件）**

```swift
struct MediaFile: Identifiable {
    let id: UUID
    let url: URL
    let title: String
    let duration: TimeInterval
    let format: MediaFormat
    let thumbnailURL: URL?
    let createdAt: Date
    let lastPlayedAt: Date?
}

enum MediaFormat {
    case video(codec: VideoCodec)
    case audio(codec: AudioCodec)
}
```

**Subtitle Segment（字幕片段）**

```swift
struct Subtitle: Identifiable {
    let id: UUID
    let mediaId: UUID          // 关联的媒体文件
    let startTime: TimeInterval
    let endTime: TimeInterval
    let text: String
    let language: String
    let confidence: Double     // 0.0 ~ 1.0
    let source: SubtitleSource // 转写/导入/手动
    
    // 计算属性
    var duration: TimeInterval { endTime - startTime }
}

enum SubtitleSource {
    case transcribed(engineId: String)
    case imported(format: String)
    case manual
}
```

**Transcription Job（转写任务）**

```swift
struct TranscriptionJob: Identifiable {
    let id: UUID
    let mediaId: UUID
    let engineId: String       // 使用的引擎
    var status: JobStatus
    var progress: Double       // 0.0 ~ 1.0
    var segments: [Subtitle]   // 已转写的片段
    let createdAt: Date
    var updatedAt: Date
    var completedAt: Date?
    var error: Error?
}

enum JobStatus {
    case pending
    case running
    case paused
    case completed
    case failed
    case cancelled
}
```

### 5.2 数据流设计

#### 5.2.1 转写数据流

```
┌─────────────┐
│ Media File  │
│  (Input)    │
└──────┬──────┘
       │
       ▼
┌─────────────┐     ┌──────────────┐
│  Audio      │────▶│  ASR Engine  │
│  Extraction │     │  (Processing)│
└─────────────┘     └──────┬───────┘
                           │
                           ▼
                    ┌──────────────┐
                    │  Raw Results │
                    │  (Segments)  │
                    └──────┬───────┘
                           │
                           ▼
                    ┌──────────────┐
                    │Post-Processing│
                    │ (Validation) │
                    └──────┬───────┘
                           │
                           ▼
                    ┌──────────────┐
                    │   Subtitle   │
                    │   Segments   │
                    │   (Stored)   │
                    └──────────────┘
```

**数据转换**：
1. 媒体文件 → 音频流（解码）
2. 音频流 → PCM 数据（重采样到 16kHz）
3. PCM 数据 → 转写结果（ASR 引擎）
4. 转写结果 → 字幕片段（格式化和验证）
5. 字幕片段 → 存储（持久化）

#### 5.2.2 播放数据流

```
[Storage] → [Subtitle Manager] → [Player Sync] → [UI Display]
               ↑                       ↑
               │                       │
         按时间查询              当前播放时间
```

### 5.3 数据存储策略

> **注意**：本节只定义存储策略，不含具体实现（见 TDD）

| 数据类型 | 存储方式 | 持久化 | 容量预估 | 清理策略 |
|---------|---------|--------|---------|---------|
| 媒体元数据 | SQLite/CoreData | 是 | <10MB | 用户手动删除 |
| 字幕片段 | SQLite/CoreData | 是 | <50MB | 跟随媒体清理 |
| 转写任务 | SQLite/CoreData | 是 | <5MB | 完成后 7 天 |
| 音频缓存 | 内存 + 临时文件 | 否 | <100MB | 实时清理 |
| 模型文件 | 应用目录 | 是 | ~50MB | 用户管理 |

**存储设计原则**：
- 结构化数据使用 SQLite/CoreData
- 大文件（音视频）不存储，只存储引用
- 临时数据使用内存或临时目录
- 敏感数据加密存储（AES-256）

**数据迁移策略**：
- 版本升级时自动迁移数据库 Schema
- 提供降级兼容（保留旧版本字段）
- 迁移失败时回滚到旧版本

### 5.4 数据一致性保证

**并发控制**：
- 使用数据库事务保证 ACID
- 读写锁防止并发冲突
- Actor 模型（Swift）保证线程安全

**数据校验**：
- 字幕时间有效性（startTime < endTime）
- 字幕不重叠（自动合并或分割）
- 关联数据完整性（外键约束）

**错误恢复**：
- 转写失败不影响已有字幕
- 存储失败自动重试 3 次
- 关键操作记录日志便于恢复

---

## 6. 接口设计

> **注意**：本节定义接口契约（协议签名），不包含具体实现（见 TDD）

### 6.1 模块接口定义

#### 6.1.1 ASREngine 协议

**功能**：语音识别引擎抽象接口

**接口签名**：

```swift
protocol ASREngine {
    /// 引擎标识符
    var id: String { get }
    
    /// 引擎名称（用于 UI 显示）
    var displayName: String { get }
    
    /// 支持的语言列表
    var supportedLanguages: [String] { get }
    
    /// 初始化引擎
    /// - Parameter config: 配置参数
    /// - Throws: ASRError.initializationFailed
    func initialize(config: ASRConfig) async throws
    
    /// 转写音频
    /// - Parameters:
    ///   - audio: 音频数据（PCM 格式，16kHz，单声道）
    ///   - language: 目标语言（可选，nil 表示自动检测）
    /// - Returns: 字幕片段数组
    /// - Throws: ASRError
    func transcribe(audio: AudioData, language: String?) async throws -> [Subtitle]
    
    /// 流式转写（可选，用于实时场景）
    /// - Parameter audioStream: 音频流
    /// - Returns: 字幕流
    func transcribeStream(_ audioStream: AsyncStream<AudioData>) 
        -> AsyncThrowingStream<Subtitle, Error>
    
    /// 取消当前转写任务
    func cancel()
    
    /// 释放资源
    func cleanup() async
}
```

**错误定义**：

```swift
enum ASRError: Error {
    case initializationFailed(reason: String)
    case modelNotFound(path: String)
    case audioFormatInvalid(expected: String, actual: String)
    case transcriptionFailed(reason: String)
    case operationCancelled
    case notSupported(feature: String)
}
```

**输入约束**：
- AudioData 必须是 PCM 格式，16kHz，单声道
- 音频长度 0.1s ~ 600s（过短或过长拒绝）
- language 使用 ISO 639-1 代码（如 "en", "zh"）

**输出保证**：
- Subtitle 数组按时间排序
- startTime < endTime
- confidence ∈ [0, 1]

**性能要求**：
- 初始化时间 < 3s
- 转写 RTF < 0.5（实时因子）
- 内存占用 < 150MB

**实现类**：
- WhisperEngine（见 `TDD-WhisperEngine.md`）
- CloudASREngine（未来扩展）

---

#### 6.1.2 SubtitleProvider 协议

**功能**：字幕数据提供者接口

**接口签名**：

```swift
protocol SubtitleProvider {
    /// 获取指定时间范围的字幕
    /// - Parameters:
    ///   - mediaId: 媒体文件 ID
    ///   - timeRange: 时间范围
    /// - Returns: 字幕片段数组
    func subtitles(for mediaId: UUID, in timeRange: ClosedRange<TimeInterval>) async throws -> [Subtitle]
    
    /// 保存字幕
    /// - Parameters:
    ///   - subtitles: 字幕数组
    ///   - mediaId: 关联的媒体 ID
    func save(_ subtitles: [Subtitle], for mediaId: UUID) async throws
    
    /// 删除字幕
    /// - Parameters:
    ///   - mediaId: 媒体文件 ID
    func deleteSubtitles(for mediaId: UUID) async throws
    
    /// 导出字幕
    /// - Parameters:
    ///   - mediaId: 媒体文件 ID
    ///   - format: 导出格式（SRT, VTT, etc.）
    /// - Returns: 导出文件 URL
    func export(mediaId: UUID, format: SubtitleFormat) async throws -> URL
}

enum SubtitleFormat {
    case srt
    case vtt
    case ass
    case json
}
```

---

#### 6.1.3 PlayerController 协议

**功能**：播放器控制接口

**接口签名**：

```swift
protocol PlayerController {
    /// 当前播放状态
    var playbackState: PlaybackState { get }
    
    /// 当前播放时间
    var currentTime: TimeInterval { get }
    
    /// 总时长
    var duration: TimeInterval { get }
    
    /// 播放速率（0.5 ~ 2.0）
    var playbackRate: Float { get set }
    
    /// 加载媒体
    /// - Parameter url: 媒体文件 URL
    func load(url: URL) async throws
    
    /// 播放
    func play()
    
    /// 暂停
    func pause()
    
    /// 跳转
    /// - Parameter time: 目标时间
    func seek(to time: TimeInterval)
    
    /// 停止
    func stop()
}

enum PlaybackState {
    case idle
    case loading
    case ready
    case playing
    case paused
    case error(Error)
}
```

---

### 6.2 外部依赖接口

| 外部库/API | 用途 | 接口约束 | 版本要求 |
|-----------|------|---------|---------|
| whisper.cpp | 语音识别引擎 | C API（FFI） | v1.5.0+ |
| AVFoundation | 音视频播放（iOS） | Native API | iOS 16+ |
| MediaCodec | 音视频解码（Android） | Native API | API 26+ |
| SQLite | 数据存储 | SQL | 3.35+ |

**FFI 封装示例**（不含具体实现）：

```swift
// whisper.cpp C API 封装
class WhisperCAPI {
    /// 初始化模型
    /// - Parameter modelPath: 模型文件路径
    /// - Returns: 模型指针
    static func initialize(modelPath: String) throws -> OpaquePointer
    
    /// 转写音频
    /// - Parameters:
    ///   - model: 模型指针
    ///   - audioData: PCM 音频数据
    /// - Returns: 转写结果
    static func transcribe(model: OpaquePointer, audioData: [Float]) throws -> [WhisperSegment]
    
    /// 释放模型
    static func free(model: OpaquePointer)
}
```

### 6.3 API 版本管理

**版本策略**：
- 使用语义化版本（Semantic Versioning）
- 主版本号变更：破坏性改动
- 次版本号变更：新增功能，向后兼容
- 补丁版本号：Bug 修复

**兼容性保证**：
- 同一主版本内保持 API 兼容
- 废弃 API 至少保留 2 个次版本
- 使用 `@available` / `@Deprecated` 标记

**示例**：

```swift
protocol ASREngine {
    // v1.0 引入
    func transcribe(audio: AudioData) async throws -> [Subtitle]
    
    // v1.1 新增，向后兼容
    @available(iOS 16, macOS 13, *)
    func transcribeStream(_ audioStream: AsyncStream<AudioData>) 
        -> AsyncThrowingStream<Subtitle, Error>
    
    // v2.0 将废弃
    @available(*, deprecated, message: "Use transcribe(audio:language:) instead")
    func transcribe(audio: AudioData, config: ASRConfig) async throws -> [Subtitle]
}
```

### 6.4 接口测试策略

**契约测试**：
- 每个接口都有契约测试（Contract Test）
- 验证输入输出符合定义
- 验证错误处理符合规范

**Mock 实现**：
- 所有协议都提供 Mock 实现
- 用于单元测试和集成测试
- 示例：`MockASREngine`, `MockSubtitleProvider`

**集成测试**：
- 验证模块间接口调用正确
- 验证数据流转正常
- 见 `docs/2_scrum/[platform]/tests/integration-tests.md`

---

## 7. 测试策略

> **注意**：本节关注集成测试策略，单元测试见 TDD

### 7.1 测试层次

| 测试层次 | 覆盖范围 | 负责人 | 文档位置 |
|---------|---------|-------|---------|
| 单元测试 | 单个类/函数 | TDD | 各模块 TDD 文档 |
| **集成测试** | 模块间交互 | **HLD** | **本节** |
| 系统测试 | 端到端流程 | Sprint Task | Sprint 测试计划 |
| 验收测试 | 用户场景 | PRD | PRD 验收标准 |

### 7.2 集成测试场景

#### 7.2.1 实时转写集成测试

**测试目标**：验证 PlayerCore → PrismASR → PrismKit 数据流正确

**测试场景**：

```
场景 1：正常播放转写流程
Given: 加载 1 分钟测试音频（16kHz, mono）
  And: 初始化 WhisperEngine（tiny 模型）
 When: 播放器开始播放
 Then: PrismASR 每 5 秒输出一批字幕
  And: SubtitleRenderer 实时显示字幕
  And: 转写延迟 < 2 秒
  And: 内存占用 < 150MB

场景 2：暂停恢复
Given: 正在播放并转写
 When: 暂停播放 10 秒
 Then: 转写任务暂停
 When: 恢复播放
 Then: 转写从断点继续
  And: 字幕时间戳连续（无重复）

场景 3：快进跳转
Given: 正在播放（位置 00:30）
 When: 快进到 02:00
 Then: 取消当前转写任务
  And: 从新位置开始转写
  And: UI 显示正确时间范围字幕
```

**测试数据**：
- 音频文件：`tests/resources/audio/sample-1min.wav`
- 模型文件：`models/ggml-tiny.bin`
- 预期字幕：`tests/resources/subtitles/sample-1min-expected.srt`

**验收标准**：
- 字幕内容准确率 > 90%（与预期对比）
- 时间戳误差 < 500ms
- 无内存泄漏（Instruments 验证）

---

#### 7.2.2 字幕持久化集成测试

**测试目标**：验证 SubtitleProvider ↔ 数据库交互

**测试场景**：

```
场景 1：批量保存和查询
Given: 转写生成 100 条字幕
 When: 调用 SubtitleProvider.save()
 Then: 数据库插入成功
 When: 查询时间范围 [00:30, 01:00]
 Then: 返回该范围内所有字幕
  And: 字幕按 startTime 排序

场景 2：并发写入保护
Given: 启动 3 个并发转写任务（同一媒体文件）
 When: 3 个任务同时保存字幕
 Then: 无数据库死锁
  And: 所有字幕正确保存
  And: 无重复记录

场景 3：导出功能
Given: 数据库中有 50 条字幕
 When: 导出为 SRT 格式
 Then: 生成符合 SRT 规范的文件
  And: 时间格式正确（00:00:00,000）
```

---

### 7.3 性能测试

#### 7.3.1 关键指标

| 指标 | 目标值 | 测试场景 | 验证方法 |
|-----|-------|---------|---------|
| 转写 RTF | < 0.5 | 10 分钟音频 | 耗时 / 音频时长 |
| 内存占用 | < 150MB | 实时转写 | Xcode Instruments |
| 启动时间 | < 2s | 冷启动 | 日志时间戳 |
| 数据库查询 | < 100ms | 1000 条字幕 | SQL EXPLAIN |
| UI 响应 | < 16ms | 滚动字幕列表 | 帧率监控 |

#### 7.3.2 负载测试

**场景 1：长时音频**
- 输入：2 小时音频文件
- 预期：持续转写无崩溃，内存稳定

**场景 2：多文件并发**
- 输入：同时打开 5 个视频
- 预期：资源正确分配，无互相干扰

**场景 3：低性能设备**
- 设备：iPhone SE (2nd gen), Android 低端机
- 预期：降级策略生效，用户体验可接受

---

### 7.4 兼容性测试

#### 7.4.1 平台版本

| 平台 | 最低版本 | 最新版本 | 测试覆盖 |
|-----|---------|---------|---------|
| iOS | 16.0 | 17.5 | 全功能 |
| macOS | 13.0 | 14.5 | 全功能 |
| Android | 8.0 (API 26) | 14 (API 34) | 全功能 |

**测试矩阵**：
- 每个平台至少测试 3 个版本（最低、中间、最新）
- 重点验证新版本 API 的向后兼容性

#### 7.4.2 音频格式

| 格式 | 采样率 | 声道 | 支持状态 | 测试文件 |
|-----|--------|------|---------|---------|
| MP3 | 16/44.1kHz | 单/双 | ✅ | sample.mp3 |
| M4A | 16/44.1kHz | 单/双 | ✅ | sample.m4a |
| WAV | 16kHz | 单 | ✅ | sample.wav |
| FLAC | 16/48kHz | 单/双 | ✅ | sample.flac |
| OGG | 16kHz | 单 | ⚠️ 部分设备 | sample.ogg |

**兼容性策略**：
- 不支持的格式：提示用户转换
- 采样率不匹配：自动重采样到 16kHz

---

### 7.5 测试环境

#### 7.5.1 持续集成（CI）

**自动化测试**：
- 每次 PR 触发：单元测试 + 集成测试（快速套件）
- 每日定时运行：完整集成测试 + 性能回归测试
- Release 前：全量测试 + 兼容性矩阵

**工具链**：
- iOS/macOS: Xcode Cloud / GitHub Actions
- Android: GitHub Actions + Firebase Test Lab
- 覆盖率: Codecov (目标 > 80%)

#### 7.5.2 测试设备

| 平台 | 设备 | OS 版本 | 用途 |
|-----|------|--------|------|
| iOS | iPhone 14 Pro | 17.5 | 主要测试 |
| iOS | iPhone SE (2nd) | 16.0 | 低端兼容 |
| macOS | MacBook Pro (M2) | 14.5 | 主要测试 |
| Android | Pixel 7 | 14 | 主要测试 |
| Android | 低端测试机 | 8.0 | 低端兼容 |

#### 7.5.3 测试数据

**音频素材**：
- `tests/resources/audio/` 目录
- 包含英文、中文、多语言混合样本
- 不同时长：10s, 1min, 10min, 1h
- 不同质量：清晰、噪音、音乐背景

**预期字幕**：
- 人工标注的参考字幕
- 用于准确率验证

### 7.6 缺陷管理

**严重级别定义**：
- P0（阻塞）：崩溃、数据丢失、核心功能不可用
- P1（严重）：主要功能异常、性能严重下降
- P2（一般）：次要功能异常、UI 问题
- P3（轻微）：文案错误、轻微 UI 瑕疵

**修复优先级**：
- P0: 24 小时内修复
- P1: 3 个工作日内修复
- P2: 下一个 Sprint
- P3: 积压处理

**回归测试**：
- 每个 Bug 修复后添加回归测试
- 防止同类问题再次出现


---

## 8. 质量属性

> **注意**：本节定义如何实现 ADD 中的质量属性决策，不重复架构层面的权衡分析

### 8.1 性能实现策略

> **参考**：架构层面的性能决策见 `ADD-[ProjectName].md` 第 2.5 节

#### 8.1.1 关键指标与实现

| 质量属性 | 目标值 | 实现策略 | 验证方法 | 负责模块 |
|---------|--------|---------|---------|---------|
| 启动时间 | < 2s | 延迟加载模型、异步初始化 | 日志时间戳 | App, PrismASR |
| 转写 RTF | < 0.5 | 批处理、GPU 加速 | 性能测试 | PrismASR |
| 内存占用 | < 150MB | 流式处理、及时释放 | Instruments | PrismASR, PlayerCore |
| UI 响应 | < 16ms | 主线程零阻塞、后台任务 | 帧率监控 | PrismKit |
| 数据库查询 | < 100ms | 索引优化、批量查询 | SQL EXPLAIN | PrismCore |

**具体实现要点**：

1. **启动优化**：
   - 第一屏渲染前不加载 ASR 引擎
   - 模型文件按需加载（用户启动转写时）
   - 数据库连接使用连接池（首次查询时建立）

2. **转写性能**：
   - 音频分片处理（每片 5-10 秒）
   - 使用 Metal/CUDA 加速推理（如设备支持）
   - 结果批量合并，减少 UI 更新频率

3. **内存管理**：
   - 音频 buffer 使用固定大小循环队列
   - 转写完成立即释放音频数据
   - 模型文件使用 mmap（减少内存拷贝）

4. **UI 流畅度**：
   - 所有耗时操作在后台线程（Actor/WorkManager）
   - UI 更新使用节流（Throttle 100ms）
   - 长列表使用虚拟滚动（RecyclerView/LazyVStack）

---

### 8.2 可靠性实现策略

> **参考**：架构层面的可靠性决策见 `ADD-[ProjectName].md` 第 2.3 节

#### 8.2.1 错误处理机制

| 错误类型 | 处理策略 | 用户体验 | 日志级别 |
|---------|---------|---------|---------|
| 模型加载失败 | 提示用户重新下载 | 错误提示 + 重试按钮 | ERROR |
| 音频格式不支持 | 自动转换或拒绝 | 格式说明 + 转换建议 | WARN |
| 转写超时 | 取消任务 + 重试 | 进度条 + 重试选项 | WARN |
| 数据库写入失败 | 自动重试 3 次 | 无感知（后台重试） | ERROR |
| 内存不足 | 降级处理（减少并发） | 性能下降提示 | WARN |

**错误恢复流程**：

```
错误发生 → 日志记录 → 本地恢复尝试 → 成功？
                                    ├─ 是 → 继续执行
                                    └─ 否 → 用户提示 → 用户选择
                                              ├─ 重试
                                              ├─ 跳过
                                              └─ 取消任务
```

**关键错误处理示例**（协议层面，无实现）：

```swift
protocol ErrorRecoveryStrategy {
    /// 判断错误是否可恢复
    func isRecoverable(_ error: Error) -> Bool
    
    /// 尝试恢复
    /// - Returns: 恢复成功返回 true
    func recover(from error: Error) async -> Bool
    
    /// 生成用户友好的错误消息
    func userMessage(for error: Error) -> String
}
```

---

### 8.3 可扩展性实现策略

> **参考**：架构层面的扩展性决策见 `ADD-[ProjectName].md` 第 2.2 节

#### 8.3.1 插件化设计

**ASR 引擎插件化**：

- 新增引擎只需实现 `ASREngine` 协议
- 通过配置文件注册引擎（无需修改业务代码）
- 运行时动态加载（见 TDD 实现细节）

**引擎注册配置**（示例）：

```json
{
  "asrEngines": [
    {
      "id": "whisper-tiny",
      "class": "WhisperEngine",
      "modelPath": "models/ggml-tiny.bin",
      "languages": ["en", "zh", "ja"]
    },
    {
      "id": "cloud-azure",
      "class": "AzureASREngine",
      "apiKey": "{{ENV.AZURE_API_KEY}}",
      "languages": ["*"]
    }
  ]
}
```

#### 8.3.2 数据模型版本化

**Subtitle 数据模型演进示例**：

```swift
// v1.0
struct Subtitle_v1 {
    let id: UUID
    let text: String
    let startTime: TimeInterval
    let endTime: TimeInterval
}

// v1.1 新增语言字段（向后兼容）
struct Subtitle_v1_1 {
    let id: UUID
    let text: String
    let startTime: TimeInterval
    let endTime: TimeInterval
    let language: String? // 可选字段
}

// v2.0 新增置信度（破坏性变更）
struct Subtitle_v2 {
    let id: UUID
    let text: String
    let startTime: TimeInterval
    let endTime: TimeInterval
    let language: String
    let confidence: Double // 必需字段
}
```

**迁移策略**：
- 数据库 Schema 版本号存储在 `metadata` 表
- 启动时检测版本，自动执行迁移脚本
- 迁移失败回滚到旧版本（保留兼容模式）

---

### 8.4 可维护性实现策略

> **参考**：架构层面的可维护性决策见 `ADD-[ProjectName].md` 第 2.4 节

#### 8.4.1 日志规范

| 日志级别 | 使用场景 | 输出目标 | 示例 |
|---------|---------|---------|------|
| DEBUG | 调试信息（开发阶段） | Console only | "音频 buffer 大小: 4096" |
| INFO | 关键流程节点 | Console + File | "开始转写任务: taskId=123" |
| WARN | 可恢复异常 | Console + File | "模型加载慢，耗时 5s" |
| ERROR | 严重错误 | Console + File + Crash | "数据库连接失败" |

**日志格式**：

```
[时间戳] [级别] [模块] [线程] 消息
2024-01-15 10:30:45.123 INFO [PrismASR] [Thread-5] 转写完成: rtf=0.35, segments=42
```

**敏感信息脱敏**：
- 不记录完整文件路径（仅文件名）
- 不记录用户音频内容
- 不记录 API Key（使用 `***` 替代）

#### 8.4.2 代码组织规范

**目录结构**（SwiftUI 示例）：

```
PrismASR/
  Sources/
    PrismASR/
      Models/          # 数据模型（符合 PrismCore 协议）
      Engines/         # ASR 引擎实现
        WhisperEngine.swift
        CloudASREngine.swift
      Services/        # 业务服务
        TranscriptionService.swift
      Utils/           # 工具类
  Tests/
    PrismASRTests/
      UnitTests/       # 单元测试（见 TDD）
      IntegrationTests/  # 集成测试（见本 HLD）
```

**命名约定**：
- 协议：`XxxProtocol` 或直接 `Xxx`（如 `ASREngine`）
- 实现类：`XxxImpl` 或具体名称（如 `WhisperEngine`）
- Mock 类：`MockXxx`（用于测试）
- ViewModel: `XxxViewModel`
- View: `XxxView`

---

### 8.5 可观测性实现策略

#### 8.5.1 关键指标采集

**埋点事件定义**：

| 事件 ID | 事件名称 | 参数 | 触发条件 | 用途 |
|--------|---------|------|---------|------|
| `asr_start` | 转写开始 | `mediaId`, `audioLength`, `language`, `modelId` | 开始转写 | 监控转写频率 |
| `asr_complete` | 转写完成 | `duration`, `segmentCount`, `rtf`, `errorCount` | 转写成功 | 性能分析 |
| `asr_error` | 转写失败 | `errorCode`, `errorMessage`, `mediaId` | 转写失败 | 错误分析 |
| `player_seek` | 播放跳转 | `fromTime`, `toTime` | 用户跳转 | 用户行为分析 |
| `export_subtitle` | 导出字幕 | `format`, `subtitleCount` | 用户导出 | 功能使用统计 |

**指标聚合**（用于监控面板）：

```
转写成功率 = asr_complete / (asr_complete + asr_error)
平均 RTF = avg(asr_complete.rtf)
P99 转写时长 = percentile(asr_complete.duration, 99)
```

#### 8.5.2 性能监控

**实时监控指标**：
- CPU 使用率（目标 < 80%）
- 内存占用（目标 < 150MB）
- 线程数（目标 < 20）
- 磁盘 I/O（目标 < 10MB/s）

**工具**：
- iOS: Xcode Instruments (CPU Profiler, Allocations)
- Android: Android Profiler (CPU, Memory, Network)
- 自定义监控：定时采样关键指标

---

### 8.6 安全性实现策略

> **参考**：架构层面的安全决策见 `ADD-[ProjectName].md` 第 6 节

#### 8.6.1 数据保护

| 数据类型 | 敏感级别 | 存储位置 | 加密方式 | 访问控制 |
|---------|---------|---------|---------|---------|
| 用户音频文件 | 高 | 用户文档目录 | 不加密（用户自有） | 文件系统权限 |
| 字幕内容 | 中 | SQLite | 不加密 | 应用沙盒 |
| API Key（未来） | 极高 | Keychain/KeyStore | 系统级加密 | 仅应用访问 |
| 用户偏好设置 | 低 | UserDefaults | 不加密 | 应用沙盒 |

**加密实现**（协议定义）：

```swift
protocol SecureStorage {
    /// 保存敏感数据
    func save(_ data: Data, forKey key: String) throws
    
    /// 读取敏感数据
    func load(forKey key: String) throws -> Data?
    
    /// 删除数据
    func delete(forKey key: String) throws
}

// 实现类：KeychainStorage, EncryptedFileStorage (见 TDD)
```

#### 8.6.2 权限管理

**必需权限**：

| 权限 | 用途 | 请求时机 | 拒绝后处理 |
|-----|------|---------|-----------|
| 文件访问 | 读取音视频文件 | 打开文件时 | 显示文件选择器 |
| 麦克风（未来） | 实时录音转写 | 用户点击录音按钮 | 禁用录音功能 |

**权限请求最佳实践**：
- 使用前提示用户权限用途
- 提供"在设置中开启"链接
- 拒绝权限后优雅降级（不崩溃）

---

### 8.7 国际化与本地化

#### 8.7.1 支持语言

| 语言 | 代码 | UI 翻译 | ASR 支持 | 优先级 |
|-----|------|--------|---------|--------|
| 简体中文 | zh-Hans | ✅ | ✅ | P0 |
| 英文 | en | ✅ | ✅ | P0 |
| 日文 | ja | 计划中 | ✅ | P1 |
| 韩文 | ko | 计划中 | ✅ | P2 |

#### 8.7.2 本地化实现

**文本本地化**：

```swift
// iOS
Text("subtitle.export.button".localized)

// Android
stringResource(R.string.subtitle_export_button)
```

**资源组织**：

```
iOS:
  Localizations/
    en.lproj/
      Localizable.strings
    zh-Hans.lproj/
      Localizable.strings

Android:
  res/
    values/strings.xml
    values-zh-rCN/strings.xml
```

**日期时间格式**：
- 使用系统 DateFormatter（自动适配用户区域）
- 字幕时间戳统一使用 `HH:mm:ss,SSS`（SRT 标准）

**RTL 支持**：
- 当前版本不支持 RTL 语言（阿拉伯语、希伯来语）
- 未来扩展时需调整 UI 布局（FlexBox 自动翻转）

---

## 9. 风险管理

### 8.2 测试范围

| 层级 | 覆盖范围 | 工具 | 目标覆盖率 |
|------|---------|------|-----------|
| 单元测试 | ViewModel, Service, Engine | XCTest / JUnit | ≥ 80% |
| 集成测试 | 模块间交互 | XCTest / Espresso | ≥ 60% |
| UI 测试 | 关键用户流程 | XCUITest / UIAutomator | 核心流程覆盖 |

### 8.3 验收标准

- [ ] 所有核心功能通过测试
- [ ] 性能指标达标
- [ ] 无 P0/P1 级别 Bug
- [ ] 代码覆盖率 ≥ 80%

## 9. 风险与依赖

---

## 9. 风险管理

> **注意**：本节关注模块层面的技术风险，架构层面的风险见 ADD

### 9.1 技术风险识别

#### 9.1.1 高优先级风险

| 风险 ID | 风险描述 | 影响范围 | 严重程度 | 概率 | 影响 |
|--------|---------|---------|---------|------|------|
| R-001 | whisper.cpp 性能不达标（RTF > 0.5） | PrismASR | 高 | 中 (40%) | 用户体验差，无法实时转写 |
| R-002 | 模型文件过大（> 100MB）导致下载失败 | PrismASR | 高 | 低 (20%) | 用户无法使用转写功能 |
| R-003 | 多线程并发导致数据库死锁 | PrismCore | 中 | 中 (30%) | 字幕保存失败，数据丢失 |
| R-004 | iOS/Android 平台 API 差异导致不一致 | 全平台 | 中 | 高 (60%) | 跨平台功能不一致 |

#### 9.1.2 中低优先级风险

| 风险 ID | 风险描述 | 影响范围 | 严重程度 | 概率 | 影响 |
|--------|---------|---------|---------|------|------|
| R-005 | 内存泄漏导致长时间运行崩溃 | 全平台 | 低 | 低 (10%) | 用户需重启应用 |
| R-006 | 第三方库版本不兼容 | 构建系统 | 低 | 低 (15%) | 编译失败 |
| R-007 | 不支持的音频格式导致转写失败 | PrismASR | 低 | 中 (40%) | 部分文件无法使用 |

---

### 9.2 风险缓解措施

#### R-001: whisper.cpp 性能不达标

**缓解措施**：

1. **提前验证**：
   - Sprint 0 完成性能基准测试（5 分钟音频，目标 RTF < 0.5）
   - 测试 3 种模型大小（tiny, base, small）
   - 在低端设备（iPhone SE 2nd）测试

2. **备选方案**：
   - Plan B: 使用更小的模型（tiny）+ 降低准确率
   - Plan C: 集成云端 ASR API（Azure/Google）作为后备

3. **监控指标**：
   - 每次 PR 运行性能回归测试
   - 监控生产环境 RTF P99 值

**触发条件**：基准测试 RTF > 0.5

**负责人**：@ASR 模块负责人

---

#### R-002: 模型文件过大

**缓解措施**：

1. **预防措施**：
   - 使用量化模型（INT8）减小体积
   - 默认提供 tiny 模型（~40MB）
   - 高级模型按需下载（可选）

2. **下载优化**：
   - 支持断点续传
   - 校验 checksum 防止损坏
   - 提供镜像下载源（CDN）

3. **降级策略**：
   - 下载失败提示用户手动放置模型文件
   - 提供云端转写选项（未来）

**触发条件**：模型文件 > 100MB

**负责人**：@ASR 模块负责人

---

#### R-003: 数据库死锁

**缓解措施**：

1. **设计规避**：
   - 所有写操作使用同一个串行队列（Swift Actor）
   - 读操作使用快照隔离级别
   - 避免长事务（< 500ms）

2. **错误恢复**：
   - 检测死锁错误码（SQLITE_BUSY）
   - 自动重试 3 次（指数退避）
   - 失败后记录错误日志

3. **测试验证**：
   - 编写并发写入集成测试
   - 压力测试（100 并发写）

**触发条件**：集成测试出现死锁

**负责人**：@PrismCore 模块负责人

---

#### R-004: 平台 API 差异

**缓解措施**：

1. **抽象隔离**：
   - 定义统一协议（如 `AudioPlayer`）
   - 每个平台单独实现（`AVPlayerWrapper`, `MediaPlayerWrapper`）
   - 通过契约测试保证行为一致

2. **差异文档**：
   - 维护平台差异对照表
   - 在 HLD 中明确标注不一致行为

3. **跨平台测试**：
   - 每个平台都运行完整测试套件
   - 对比测试结果差异

**触发条件**：发现平台行为不一致

**负责人**：@跨平台架构师

---

### 9.3 依赖管理

#### 9.3.1 模块依赖关系

```
[Sprint 依赖图]

Sprint 0: 项目搭建 + 性能验证
    ├─ 输出：项目结构、性能基准
    └─ 阻塞：无

Sprint 1: PrismCore + PrismASR
    ├─ 输出：ASR 引擎可用、数据模型定义
    └─ 阻塞：Sprint 2, Sprint 3

Sprint 2: PlayerCore + PrismKit (UI)
    ├─ 依赖：Sprint 1 (数据模型)
    ├─ 输出：播放器 + UI 组件
    └─ 阻塞：Sprint 3

Sprint 3: Integration + Testing
    ├─ 依赖：Sprint 1, Sprint 2
    ├─ 输出：完整功能 + 测试报告
    └─ 阻塞：Release
```

#### 9.3.2 外部依赖风险

| 依赖 | 版本 | 风险 | 缓解措施 |
|-----|------|------|---------|
| whisper.cpp | v1.5.0 | 更新频繁，API 可能变化 | 锁定版本，定期评估升级 |
| AVFoundation | iOS 16+ | 新系统 API 可能有 bug | 测试覆盖多个 iOS 版本 |
| SQLite | 3.35+ | 低（成熟稳定） | 无需特殊处理 |

---

### 9.4 未决问题（Open Issues）

> **说明**：记录设计阶段未解决的技术问题，需在实现前明确

| 问题 ID | 问题描述 | 影响模块 | 优先级 | 预计解决时间 | 负责人 | 状态 |
|--------|---------|---------|--------|-------------|--------|------|
| I-001 | 是否支持视频文件中的多音轨？ | PlayerCore | P2 | Sprint 1 开始前 | @Product | 🟡 讨论中 |
| I-002 | 字幕导出格式优先级（SRT/VTT/ASS） | PrismCore | P1 | Sprint 2 开始前 | @Tech Lead | 🟡 讨论中 |
| I-003 | 是否需要支持字幕编辑功能？ | PrismKit | P3 | v0.2 评审 | @Product | 🔴 待决定 |
| I-004 | Android 最低 API 版本（26 vs 28） | 全平台 | P0 | 立即 | @Tech Lead | 🟢 已解决 |

**问题状态说明**：
- 🔴 待决定：尚未开始讨论
- 🟡 讨论中：正在评估方案
- 🟢 已解决：已有明确决策

**问题处理流程**：
1. 每周 Scrum 会议回顾未决问题
2. 阻塞问题升级至架构委员会
3. 所有问题在进入对应 Sprint 前必须解决

---

### 9.5 假设与约束

> **参考**：架构层面的约束见 `ADD-[ProjectName].md` 第 8 节

#### 9.5.1 技术假设

| 假设 | 验证方式 | 风险 | 备注 |
|-----|---------|------|------|
| whisper.cpp 在移动端性能可接受 | Sprint 0 基准测试 | 高 | 如不成立，考虑云端方案 |
| 用户设备存储空间 > 500MB | 产品数据分析 | 低 | 模型 + 缓存需要空间 |
| 用户网络环境支持下载大文件 | 无需验证 | 低 | 提供离线替代方案 |

#### 9.5.2 业务约束

| 约束 | 来源 | 影响 | 备注 |
|-----|------|------|------|
| 不能上传用户音频到云端 | 隐私政策 | 限制云端 ASR 使用 | 仅本地转写 |
| 必须支持离线使用 | PRD 需求 | 需内置模型文件 | 增加包体积 |
| 首个版本只支持中英文 | 产品规划 | 限制语言模型选择 | 未来扩展 |

#### 9.5.3 资源约束

| 资源 | 限制 | 影响 | 缓解措施 |
|-----|------|------|---------|
| 开发人力 | 2 人（iOS/Android 各 1） | 开发周期长 | 优先实现 MVP |
| 测试设备 | 每平台 2 台 | 兼容性测试不足 | 使用模拟器 + 云测试 |
| CI/CD 预算 | 有限 | 自动化测试受限 | 优先核心测试 |

---

## 附录

### A. 术语表

| 术语 | 全称 | 定义 |
|------|------|------|
| ASR | Automatic Speech Recognition | 自动语音识别，将语音转换为文本 |
| RTF | Real-Time Factor | 实时因子，转写耗时 / 音频时长 |
| FFI | Foreign Function Interface | 外部函数接口，用于调用 C/C++ 代码 |
| MVVM | Model-View-ViewModel | 架构模式，分离 UI 和业务逻辑 |
| ERD | Entity-Relationship Diagram | 实体关系图，数据库设计图 |
| PCM | Pulse Code Modulation | 脉冲编码调制，原始音频格式 |
| ADR | Architecture Decision Record | 架构决策记录 |
| HLD | High-Level Design | 高层设计文档（本文档） |
| TDD | Technical Design Document | 技术设计文档 |
| SRT | SubRip Subtitle | 常见字幕格式 |
| VTT | WebVTT | Web 视频文本轨道格式 |

---

### B. 参考文档

#### B.1 上游文档（输入）

- **PRD**: `docs/0_prd/prd_v[版本].md`  
  *产品需求文档，定义功能需求和验收标准*

- **技术可行性**: `docs/1_design/feasibility/technical-feasibility-[platform]-v[版本].md`  
  *验证技术方案可行性*

- **ADD**: `docs/1_design/architecture/add/add-[ProjectName]-v[版本].md`  
  *架构设计文档，定义架构决策和风格*

- **ADR**: `docs/1_design/architecture/adr/[编号]-[标题].md`  
  *架构决策记录，记录关键技术决策*

#### B.2 下游文档（输出）

- **TDD**: `docs/1_design/tdd/[模块名]-tdd-v[版本].md`  
  *技术设计文档，包含具体实现细节和代码*

- **Sprint 计划**: `docs/2_scrum/[platform]/sprint-plan-v[版本].md`  
  *迭代计划，分解任务和时间安排*

- **测试计划**: `docs/2_scrum/[platform]/tests/test-plan-v[版本].md`  
  *测试用例和验收标准*

#### B.3 外部参考

- [whisper.cpp GitHub](https://github.com/ggerganov/whisper.cpp) - ASR 引擎文档
- [SwiftUI Documentation](https://developer.apple.com/documentation/swiftui/) - Apple 官方文档
- [Jetpack Compose](https://developer.android.com/jetpack/compose) - Android 官方文档
- [Semantic Versioning](https://semver.org/) - 版本管理规范

---

### C. 平台差异对照表

| 功能 | iOS/macOS | Android | 备注 |
|-----|-----------|---------|------|
| 音频播放 | AVFoundation | MediaPlayer | API 基本等价 |
| 线程模型 | Dispatch Queue / Actor | Coroutines | 异步模式不同 |
| 数据库 | CoreData / SQLite | Room / SQLite | Android 推荐 Room |
| UI 框架 | SwiftUI | Jetpack Compose | 声明式 UI，理念相似 |
| 文件系统 | FileManager | File API | 权限模型差异大 |
| 后台任务 | BackgroundTasks | WorkManager | Android 限制更严格 |

**关键差异说明**：
- **权限管理**：iOS 更灵活，Android 需要声明 manifest
- **后台限制**：Android 对后台任务限制更严格
- **UI 生命周期**：SwiftUI 自动管理，Compose 需手动处理部分场景

---

### D. 设计决策日志

| 日期 | 决策 | 原因 | 影响 | 决策人 |
|------|------|------|------|--------|
| 2024-01-10 | 使用 whisper.cpp 而非云端 ASR | 隐私保护 + 离线支持 | 增加包体积，性能依赖设备 | @Tech Lead |
| 2024-01-12 | 选择 tiny 模型作为默认 | 平衡性能和准确率 | 准确率可能不如 base 模型 | @ASR Lead |
| 2024-01-15 | 数据库使用 SQLite | 跨平台一致性 | Android 端放弃 Room 优势 | @架构师 |

---

### E. 模块接口清单

| 模块 | 接口协议 | 文档位置 |
|------|---------|---------|
| PrismCore | `ASREngine`, `SubtitleProvider`, `PlayerController` | 第 6.1 节 |
| PrismASR | 实现 `ASREngine` | `TDD-PrismASR.md` |
| PlayerCore | 实现 `PlayerController` | `TDD-PlayerCore.md` |
| PrismKit | UI 组件（无独立协议） | `TDD-PrismKit.md` |

---

### F. 变更记录

| 版本 | 日期 | 作者 | 变更内容 |
|------|------|------|---------|
| v1.1 | 2024-01-20 | @架构师 | 新增风险管理章节，补充平台差异表 |
| v1.0 | 2024-01-10 | @架构师 | 初始版本，定义模块结构和接口 |

---

**模板版本**: v2.0  
**最后更新**: 2025-01-15  
**维护**: @架构团队

**审阅流程**：
1. 初稿完成 → 技术评审（Tech Lead）
2. 通过评审 → 团队评审（全员）
3. 无重大异议 → 批准发布
4. 实现过程中变更 → 更新版本号 + 变更记录
