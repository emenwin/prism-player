# Prism Player HLD v0.2 架构设计评审报告

> 评审版本：v0.2  
> 评审日期：2025-10-17  
> 评审范围：iOS + macOS 高级架构设计文档  
> 评审人：AI 架构师  

---

## 执行摘要

本文档对 Prism Player HLD v0.2 进行全面评审。整体而言，该架构设计**质量优秀**，展现了对移动端音视频处理、端侧 AI 推理和跨平台开发的深刻理解。设计完整度高、技术选型合理、风险识别到位。

**总体评分：8.5/10**

### 主要优势
- ✅ 架构分层清晰，MVVM + 服务模块化适配移动端最佳实践
- ✅ 双 ASR 后端策略（whisper.cpp + MLX Swift）前瞻性强
- ✅ 性能指标量化（KPI 分级）与 PRD 对齐良好
- ✅ 跨平台策略务实（iOS/macOS 代码共享 + 平台差异化）
- ✅ 内存/缓存/能耗管理考虑周全
- ✅ i18n/a11y 与隐私合规符合生产级要求

### 需要改进的方面
- ⚠️ 某些技术细节仍有模糊性（如 VAD 对齐方案）
- ⚠️ 测试策略与质量保证措施描述不足
- ⚠️ 性能监控与降级策略的实施细节需补充
- ⚠️ 错误恢复路径需要更具体的状态机定义

---

## 1. 架构设计评审

### 1.1 整体架构 ⭐⭐⭐⭐⭐

**优点：**
- 多层分离（UI/ViewModel/UseCase/Service/Engine）职责清晰，符合 Clean Architecture 原则
- 组件模块化设计优秀，每个 Service 职责单一
- 采用 Swift Concurrency（actor/Task/AsyncSequence）是正确的现代化选择
- 可插拔 ASR 后端设计体现良好的扩展性

**建议：**
1. **依赖注入容器**：建议明确 DI 策略（Protocol-based DI vs Swinject 等容器），避免后期循环依赖
2. **边界定义**：各层间的数据传递建议使用 DTO（Data Transfer Object），避免领域模型泄漏到 UI 层
3. **事件总线**：考虑引入轻量事件机制（Combine/AsyncStream）用于跨模块通知（如内存警告、模型切换）

```swift
// 建议补充：依赖注口协议示例
protocol ServiceContainer {
    var playerService: PlayerService { get }
    var asrEngine: AsrEngine { get }
    var subtitleStore: SubtitleStore { get }
    // ...
}
```

### 1.2 数据流与状态管理 ⭐⭐⭐⭐

**优点：**
- 播放器时钟作为唯一真相来源（Single Source of Truth）设计正确
- 状态机概念清晰（waiting/running/success/failure）

**问题：**
1. **状态转换规则**：缺少明确的状态转换图（State Transition Diagram），建议补充：
   ```
   Idle → Loading → Ready → Playing/Paused → Seeking → Playing
                                          ↓
                                     Error → Retry/Failed
   ```

2. **并发冲突处理**：当用户快速 seek 时，如何取消过期任务并避免竞态条件？建议明确：
   - 使用 `Task.isCancelled` 检查点
   - 每次 seek 生成新的 `seekId`，仅处理最新的结果

3. **状态持久化**：是否需要保存播放进度与字幕生成进度？重启后恢复？建议补充恢复策略。

### 1.3 跨平台策略 ⭐⭐⭐⭐⭐

**优点：**
- iOS/macOS 差异点识别准确（文件访问、后台策略、UI）
- SwiftUI 跨平台共享 + 条件编译的平衡把握良好

**建议：**
1. **Catalyst 考虑**：macOS 版本是否考虑 Mac Catalyst？若不考虑需明确说明原因
2. **平台抽象层**：建议封装平台差异为统一协议：
   ```swift
   protocol PlatformBridge {
       func requestFileAccess() async throws -> URL
       func enableBackgroundProcessing(options: BackgroundOptions) async
       func registerMemoryPressureHandler(_ handler: @escaping () -> Void)
   }
   ```

---

## 2. ASR 引擎设计评审

### 2.1 双后端策略 ⭐⭐⭐⭐⭐

**优点：**
- whisper.cpp 作为成熟基线，MLX Swift 作为性能优化路径，策略合理
- 统一 `AsrEngine` 协议设计优秀，便于测试与切换
- 模型元数据扩展（backend、supportsTimestamps）考虑周全

**建议：**
1. **性能基准测试**：需要建立两个后端的性能对比基准（RTF、内存、能耗），形成决策数据
2. **回退逻辑**：当 MLX 不可用时的回退路径需要**自动化测试**覆盖
3. **模型兼容性矩阵**：建议维护一个模型兼容性表：
   | 模型名称 | whisper.cpp | MLX Swift | 时间戳支持 | 推荐设备 |
   |---------|-------------|-----------|-----------|---------|
   | tiny.en | ✅          | ✅        | ✅        | 入门级   |
   | base.q5 | ✅          | ⚠️        | ✅        | 中端+    |

### 2.2 时间戳对齐问题 ⭐⭐⭐

**问题：**
1. **VAD + 对齐方案模糊**：对于不支持时间戳的 MLX 模型，当前描述"VAD 切段 + 简易对齐/能量峰值"过于粗略，需要：
   - 明确 VAD 库选择（Silero VAD? 自研？）
   - 对齐算法（DTW? 能量峰值? CTC 强制对齐？）
   - **精度保证**：如何确保 ±200ms 指标？需要实验数据支撑

2. **建议方案**：
   ```
   Option 1：优先使用支持时间戳的 Whisper 模型（推荐）
   Option 2：集成 Silero VAD + 滑窗对齐（需验证精度）
   Option 3：短窗口推理（10s）+ 能量包络对齐（精度降级，需 UI 提示）
   ```

### 2.3 模型管理 ⭐⭐⭐⭐

**优点：**
- 下载/导入/校验流程完整
- SHA256 校验保证完整性
- 空间检查与清理机制

**建议：**
1. **增量更新**：模型版本更新时是否支持差分下载？（降低流量消耗）
2. **签名验证**：除 SHA256 外，是否考虑数字签名验证防篡改？
3. **模型压缩**：gguf 模型是否考虑二次压缩（.zip）传输后解压？

---

## 3. 性能与资源管理评审

### 3.1 内存管理 ⭐⭐⭐⭐

**优点：**
- LRU 缓存策略合理
- 内存警告响应机制明确（保留当前 ±15s）
- 长视频禁止全量驻留的设计正确

**建议：**
1. **内存预算**：建议明确各组件的内存预算：
   - 音频缓存：≤ 10MB ✅
   - ASR 引擎运行时：≤ 200MB（需根据模型实测）
   - 字幕存储（内存态）：≤ 5MB
   - **总预算**：建议 ≤ 300MB（iPhone SE 2020 基准）

2. **内存泄漏检测**：建议在 CI 中集成 Instruments Leaks 自动化检测

3. **图片资源**：若播放视频，视频帧解码的内存占用如何控制？AVPlayer 会自动管理，但需确认。

### 3.2 能耗管理 ⭐⭐⭐⭐

**优点：**
- 后台降速、段间节流策略合理
- macOS App Nap 抑制方案正确

**建议：**
1. **电量阈值**：建议明确低电量模式触发阈值（iOS <20%? 系统 Low Power Mode?）
2. **能耗监控**：是否集成 MetricKit 监控能耗与热管理事件？
3. **用户控制**：是否允许用户在设置中选择"性能优先"或"省电优先"模式？

### 3.3 性能指标与监控 ⭐⭐⭐

**问题：**
1. **实时监控缺失**：如何在运行时监控 RTF、首帧时间并触发降级？需要补充：
   - `PerformanceMonitor` 组件设计
   - 指标采集点（开始/结束/失败）
   - 降级决策逻辑（连续 3 次 RTF < 0.3 → 提示切换模型）

2. **建议补充**：
   ```swift
   actor PerformanceMonitor {
       func recordSegmentProcessing(duration: TimeInterval, audioLength: TimeInterval)
       func shouldTriggerDegradation() -> Bool
       func getMetricsSummary() -> MetricsSummary
   }
   ```

---

## 4. 并发与调度评审

### 4.1 JobScheduler 设计 ⭐⭐⭐⭐

**优点：**
- 三级优先级（抢占/滚动/预加载）设计合理
- 取消传播机制符合 Swift Concurrency 最佳实践

**建议：**
1. **队列实现细节**：建议明确使用：
   - `TaskGroup` 还是自定义 `AsyncStream`？
   - 如何实现优先级抢占（Task Priority API?）
   - 最大并发数限制（避免资源耗尽）

2. **死锁预防**：多个 actor 交互时如何避免死锁？建议：
   - 明确调用链方向（单向依赖）
   - 避免 actor 间相互 await

3. **代码示例**（建议补充）：
   ```swift
   actor JobScheduler {
       private var activeJobs: [JobID: Task<Void, Error>] = [:]
       
       func schedule(job: RecognitionJob, priority: JobPriority) async throws {
           // 取消低优先级冲突任务
           // 启动新任务并管理生命周期
       }
       
       func cancelJobs(matching predicate: (JobID) -> Bool) async {
           // 批量取消
       }
   }
   ```

---

## 5. 错误处理与恢复评审

### 5.1 错误分类 ⭐⭐⭐⭐

**优点：**
- 错误分类全面（媒体/空间/模型/权限/后台）
- 错误到用户提示的映射思路正确

**问题：**
1. **错误恢复路径不明确**：每种错误的恢复策略需要细化：
   ```
   媒体不支持 → 提示 + 回到选择界面
   空间不足 → 提示 + 清理入口 + 重试
   模型损坏 → 重新下载 OR 切换备用模型
   权限拒绝 → 跳转系统设置
   ```

2. **重试策略**：哪些错误可重试？重试次数上限？退避算法？建议补充。

3. **降级路径**：当核心功能不可用时的最小可用功能是什么？
   - 示例：ASR 完全失败 → 仅播放器可用，字幕功能禁用

### 5.2 诊断与可观测性 ⭐⭐⭐

**建议：**
1. **结构化日志**：建议使用 OSLog 的统一日志系统，分级别（Debug/Info/Error）
2. **诊断包格式**：建议明确诊断包内容：
   - `device.json`（设备型号、OS 版本、内存）
   - `config.json`（设置、模型版本）
   - `timeline.jsonl`（关键事件时序）
   - `errors.jsonl`（错误堆栈）
3. **隐私脱敏**：确保诊断包不含文件路径、媒体元数据等隐私信息

---

## 6. 测试策略评审

### 6.1 测试覆盖 ⭐⭐⭐ ⚠️

**问题：**
当前 HLD 对测试策略描述不足，仅提及"金样本短音频回归"。建议补充：

1. **单元测试**：
   - 各 Service 的协议 mock 测试
   - 状态机转换逻辑测试
   - 缓存 LRU 算法测试
   - 导出格式化测试（SRT/VTT）

2. **集成测试**：
   - 播放-抽取-识别-渲染端到端流程
   - 模型下载-校验-加载流程
   - 进度拖动-抢占-恢复流程

3. **性能测试**：
   - 不同设备档位的 RTF 基准测试
   - 长视频（1-3 小时）内存稳定性测试
   - 后台切换恢复测试

4. **UI 测试**：
   - 关键流程的 XCUITest 自动化
   - VoiceOver 可访问性测试

5. **ASR 质量测试**：
   - 金样本音频集（不同语言、口音、噪声等级）
   - WER（Word Error Rate）基准
   - 时间戳精度验证（±200ms）

### 6.2 测试数据管理 ⭐⭐⭐

**建议：**
1. **金样本库**：建立分类的测试音频集：
   - `samples/clean/en/sample1.wav`（清晰英文）
   - `samples/noisy/zh/sample2.wav`（噪声中文）
   - `samples/fast/en/sample3.wav`（快语速）

2. **预期结果**：每个样本附带预期输出：
   - `sample1.expected.json`（包含 segments + 时间戳）
   - CI 回归时比对实际输出与预期的 diff

---

## 7. UI/UX 与可访问性评审

### 7.1 UI 架构 ⭐⭐⭐⭐

**优点：**
- MVVM 分离清晰
- SwiftUI 跨平台复用

**建议：**
1. **组件化**：建议将通用 UI 组件抽象为独立 Package：
   - `PrismUIKit`（按钮、卡片、加载指示器、字幕样式组件）
   - 便于复用与单独测试

2. **状态驱动 UI**：确保所有 UI 变化由 ViewModel 状态驱动，避免命令式更新

3. **动画与过渡**：字幕滚动、加载占位的动画需要流畅（60fps），建议：
   - 使用 `withAnimation` 而非手动 transaction
   - 避免在渲染循环中重计算布局

### 7.2 可访问性（a11y） ⭐⭐⭐⭐

**优点：**
- 动态字体、色彩对比、屏幕阅读器考虑周全
- "朗读字幕"冲突识别正确

**建议：**
1. **VoiceOver 测试**：需要实际设备测试 VoiceOver 导航流程
2. **减少动画**（Reduce Motion）：是否响应系统设置减少动画？
3. **对比度增强**：是否支持高对比度模式？

### 7.3 国际化（i18n） ⭐⭐⭐⭐⭐

**优点：**
- String Catalog 使用正确
- 禁用硬编码字符串

**建议：**
1. **复数规则**：确保支持复数形式（如 "1 model" vs "2 models"）
2. **RTL 支持**：虽然首期仅中英，但布局是否为未来 RTL 语言（阿拉伯语）预留灵活性？
3. **翻译质量**：建议引入 i18n review 流程，避免机器翻译直接上线

---

## 8. 安全与隐私评审

### 8.1 隐私合规 ⭐⭐⭐⭐⭐

**优点：**
- 默认离线工作，不上传数据
- 清理工具齐全
- 权限说明清晰

**建议：**
1. **隐私清单**（iOS 17+）：需要创建 PrivacyInfo.xcprivacy，声明：
   - 文件访问用途
   - 网络请求域名（仅模型下载）
   - 无第三方 SDK 跟踪

2. **数据最小化**：确保不收集不必要的元数据（如文件名可能包含隐私信息）

### 8.2 许可与合规 ⭐⭐⭐⭐

**优点：**
- 第三方许可披露计划

**建议：**
1. **开源许可审查**：
   - whisper.cpp: MIT ✅
   - MLX Swift: MIT ✅（需确认）
   - 模型许可：需明确支持的模型来源（OpenAI Whisper: MIT）

2. **许可展示**：在"关于"页使用 `LicenseList.plist` 或嵌入 markdown

---

## 9. 工程实践评审

### 9.1 代码规范 ⭐⭐⭐⭐⭐

**优点：**
- SwiftLint 严格模式
- String Catalog 强制国际化

**建议：**
1. **代码审查 Checklist**：建立 PR 模板，包含：
   - [ ] 无硬编码字符串
   - [ ] 新增功能有单元测试
   - [ ] VoiceOver 标签已添加
   - [ ] 性能影响评估（若适用）

2. **格式化**：是否使用 swift-format 自动格式化？

### 9.2 持续集成（CI） ⭐⭐⭐

**建议补充：**
1. **CI 流程**：
   ```yaml
   - Build iOS/macOS targets
   - Run unit tests
   - Run SwiftLint
   - Run integration tests (golden samples)
   - Archive & export
   ```

2. **多平台矩阵**：
   - iOS 17.0 / 18.0
   - macOS 14.0 / 15.0
   - Xcode 15.x / 16.x

3. **性能回归**：定期运行性能测试，监控 RTF 变化趋势

### 9.3 版本管理 ⭐⭐⭐⭐

**优点：**
- 数据版本与迁移考虑

**建议：**
1. **语义化版本**：采用 SemVer（x.y.z）
2. **变更日志**：维护 CHANGELOG.md
3. **API 稳定性**：核心协议（AsrEngine、SubtitleStore）的 breaking change 需要明确沟通

---

## 10. 开放问题与风险评估

### 10.1 已识别风险（文档中提到） ✅

| 风险 | 缓解措施 | 评估 |
|-----|---------|------|
| 性能不足（低端设备） | 小模型/限窗/降级提示 | ✅ 合理 |
| 背景限制（iOS） | 播放中可行/任务化 | ✅ 合理 |
| 存储压力 | 体积提示/空间检查/清理 | ✅ 合理 |
| 语言检测误差 | 手动指定/持久化 | ✅ 合理 |
| 许可合规 | 哈希校验/可信来源 | ✅ 合理 |

### 10.2 新增风险（本评审识别） ⚠️

| 风险 | 影响 | 建议缓解 |
|-----|------|---------|
| MLX Swift 在 iOS 的成熟度 | 高 | 以 macOS 优先，iOS 作为实验功能，明确 Beta 标识 |
| VAD 对齐精度不达标 | 中 | 建立精度基准测试，不达标则回退 whisper.cpp |
| 双后端维护成本 | 中 | 统一协议 + 契约测试，自动化覆盖率 >80% |
| 长视频（>3h）稳定性 | 高 | 压力测试 + 内存监控，建立长视频测试集 |
| 跨版本数据迁移失败 | 中 | 迁移脚本单元测试 + 降级路径（重建） |
| App Store 审核风险（模型下载） | 低 | 确保首次启动引导清晰，避免"功能不完整"拒审 |

---

## 11. 推荐的优先级改进项

### 🔴 高优先级（M1 前必须解决）

1. **明确 VAD + 对齐方案**（若支持非时间戳模型）
   - 选择 VAD 库
   - 验证 ±200ms 精度可达性
   - 不可达则移除该路径

2. **补充状态机定义**
   - 播放器状态转换图
   - 错误恢复路径
   - 并发冲突处理逻辑

3. **建立性能基准测试**
   - 金样本音频集（至少 10 个样本，覆盖不同场景）
   - 自动化回归测试
   - 设备档位验证（高/中/入门各一款）

4. **依赖注入与测试架构**
   - 明确 DI 策略
   - Mock/Stub 协议设计
   - 单元测试框架搭建

### 🟡 中优先级（M2 前解决）

5. **性能监控与降级逻辑**
   - `PerformanceMonitor` 组件设计
   - 降级触发条件与用户提示

6. **诊断包格式定义**
   - 结构化日志方案
   - 隐私脱敏规则
   - 导出与反馈流程

7. **CI/CD 流程建立**
   - 多平台构建矩阵
   - 自动化测试集成
   - 性能回归监控

### 🟢 低优先级（M3 或后续）

8. **高级优化**
   - 模型增量更新
   - 数字签名验证
   - Core ML 路线评估

9. **用户体验增强**
   - 性能/省电模式切换
   - 高级设置暴露（置信度阈值等）
   - 字幕质量评分分析

---

## 12. 总结与建议

### 12.1 整体评价

Prism Player HLD v0.2 是一份**高质量的架构设计文档**，体现了对移动端音视频处理、端侧 AI 推理和跨平台开发的**深刻理解**。架构分层清晰、技术选型合理、风险识别到位。

**特别亮点：**
- 双 ASR 后端策略（whisper.cpp + MLX Swift）展现了对新技术的前瞻性探索
- 性能指标量化（设备档位分级）避免了"典型设备"的歧义
- 内存/缓存/能耗管理的细致考虑符合生产级应用要求
- 跨平台策略务实，iOS/macOS 代码复用与差异化平衡良好

**主要不足：**
- 某些技术细节仍有模糊性（VAD 对齐、状态机、并发调度实现）
- 测试策略与质量保证措施描述不足
- 性能监控与降级策略的实施细节需补充
- 错误恢复路径需要更具体的定义

### 12.2 下一步行动

1. **立即行动**（进入 TDD 前）：
   - 补充状态机与错误恢复路径定义
   - 明确 VAD + 对齐方案（或移除该路径）
   - 建立金样本测试集与自动化框架
   - 定义 DI 策略与测试架构

2. **M1 开发期间**：
   - 实现核心协议与 whisper.cpp 后端
   - 建立性能基准测试并验证指标
   - 搭建 CI 流程
   - 完成单元测试覆盖（目标 >70%）

3. **M2 及后续**：
   - 引入 MLX Swift 后端（实验性）
   - 完善性能监控与降级逻辑
   - 长视频稳定性测试
   - 用户体验优化

### 12.3 最终建议

**批准进入详细 TDD 阶段**，但需在开发前解决以下**阻塞项**：

1. ✅ VAD + 对齐方案明确（或移除）
2. ✅ 状态机与错误恢复路径定义
3. ✅ 测试策略与金样本建立
4. ✅ DI 策略确认

完成以上项目后，可以开始编码实现。建议采用**迭代式开发**：
- **M1**：核心流程 + whisper.cpp + 基础 UI（2-3 周）
- **M2**：模型管理 + 缓存优化 + VTT 导出（2-3 周）
- **M3**：MLX Swift + 性能优化 + 稳定性加固（3-4 周）

---

## 附录：评审检查清单

- [x] 架构分层清晰且符合最佳实践
- [x] 技术选型有充分理由
- [x] 性能指标量化且可测量
- [x] 跨平台策略合理
- [⚠️] 状态管理与并发设计明确（部分模糊）
- [⚠️] 错误处理与恢复路径清晰（需补充）
- [⚠️] 测试策略完善（描述不足）
- [x] 安全与隐私合规
- [x] i18n/a11y 考虑周全
- [⚠️] 风险识别与缓解措施（部分新风险）
- [x] 工程实践（代码规范、CI）
- [x] 与 PRD 对齐

**总体评分：8.5/10**

---

**评审人签名：** AI 架构师  
**评审日期：** 2025-10-17  
**下次评审：** TDD 完成后

---

*本文档遵循 Prism Player 项目的文档规范，使用 Markdown 格式，所有文本国际化友好（中英文）。*
